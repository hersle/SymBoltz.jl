var documenterSearchIndex = {"docs":
[{"location":"components/#Components-(submodels)","page":"Components (submodels)","title":"Components (submodels)","text":"","category":"section"},{"location":"components/#Spacetimes","page":"Components (submodels)","title":"Spacetimes","text":"","category":"section"},{"location":"components/#SymBoltz.metric","page":"Components (submodels)","title":"SymBoltz.metric","text":"metric(; name = :g, kwargs...)\n\nCreate a symbolic component for the perturbed FLRW spacetime metric in the conformal Newtonian gauge with sign signature diag(-1, +1, +1, +1).\n\n\n\n\n\n","category":"function"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"g = SymBoltz.metric()\nnothing # hide","category":"page"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"<details>\n<summary><h4 style=\"display: inline-block\">Equations</h4></summary>","category":"page"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"equations(g)","category":"page"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"</details>","category":"page"},{"location":"components/#Gravitational-theories","page":"Components (submodels)","title":"Gravitational theories","text":"","category":"section"},{"location":"components/#SymBoltz.general_relativity","page":"Components (submodels)","title":"SymBoltz.general_relativity","text":"general_relativity(g; name = :G, kwargs...)\n\nCreate a symbolic component for the general relativistic (GR) theory of gravity in the spacetime with the metric g.\n\n\n\n\n\n","category":"function"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"G = SymBoltz.general_relativity(g)\nnothing # hide","category":"page"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"<details>\n<summary><h4 style=\"display: inline-block\">Equations</h4></summary>","category":"page"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"equations(G)","category":"page"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"</details>\n<details>\n<summary><h4 style=\"display: inline-block\">Initialization equations</h4></summary>","category":"page"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"initialization_equations(G)","category":"page"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"</details>","category":"page"},{"location":"components/#SymBoltz.brans_dicke","page":"Components (submodels)","title":"SymBoltz.brans_dicke","text":"brans_dicke(g; name = :G, kwargs...)\n\nCreate a symbolic component for the Brans-Dicke (BD) theory of gravity in the spacetime with the metric g.\n\n\n\n\n\n","category":"function"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"G = SymBoltz.brans_dicke(g)\nnothing # hide","category":"page"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"<details>\n<summary><h4 style=\"display: inline-block\">Equations</h4></summary>","category":"page"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"equations(G)","category":"page"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"</details>\n<details>\n<summary><h4 style=\"display: inline-block\">Initialization equations</h4></summary>","category":"page"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"initialization_equations(G)","category":"page"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"</details>","category":"page"},{"location":"components/#Species","page":"Components (submodels)","title":"Species","text":"","category":"section"},{"location":"components/#Generic","page":"Components (submodels)","title":"Generic","text":"","category":"section"},{"location":"components/#SymBoltz.species_constant_eos","page":"Components (submodels)","title":"SymBoltz.species_constant_eos","text":"species_constant_eos(g, w, cₛ² = w, ẇ = 0, _σ = 0; θinteract = false, kwargs...)\n\nCreate a symbolic component for a particle species with equation of state w ~ P/ρ in the spacetime with the metric g.\n\n\n\n\n\n","category":"function"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"using SymBoltz: τ\n@variables w(τ)\ns = SymBoltz.species_constant_eos(g, w)\nnothing # hide","category":"page"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"<details>\n<summary><h4 style=\"display: inline-block\">Equations</h4></summary>","category":"page"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"equations(s)","category":"page"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"</details>\n<details>\n<summary><h4 style=\"display: inline-block\">Initialization equations</h4></summary>","category":"page"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"initialization_equations(s)","category":"page"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"</details>","category":"page"},{"location":"components/#Relativistic","page":"Components (submodels)","title":"Relativistic","text":"","category":"section"},{"location":"components/#SymBoltz.radiation","page":"Components (submodels)","title":"SymBoltz.radiation","text":"radiation(g; name = :r, kwargs...)\n\nCreate a particle species for radiation (with equation of state w ~ 1/3) in the spacetime with metric g.\n\n\n\n\n\n","category":"function"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"r = SymBoltz.radiation(g)\nnothing # hide","category":"page"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"<details>\n<summary><h4 style=\"display: inline-block\">Equations</h4></summary>","category":"page"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"equations(r)","category":"page"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"</details>\n<details>\n<summary><h4 style=\"display: inline-block\">Initialization equations</h4></summary>","category":"page"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"initialization_equations(r)","category":"page"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"</details>","category":"page"},{"location":"components/#SymBoltz.photons","page":"Components (submodels)","title":"SymBoltz.photons","text":"photons(g; polarization = true, lmax = 6, name = :γ, kwargs...)\n\nCreate a particle species for photons in the spacetime with metric g.\n\n\n\n\n\n","category":"function"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"γ = SymBoltz.photons(g; lmax = 6)\nnothing # hide","category":"page"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"<details>\n<summary><h4 style=\"display: inline-block\">Equations</h4></summary>","category":"page"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"equations(γ)","category":"page"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"</details>\n<details>\n<summary><h4 style=\"display: inline-block\">Initialization equations</h4></summary>","category":"page"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"initialization_equations(γ)","category":"page"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"</details>","category":"page"},{"location":"components/#Non-relativistic","page":"Components (submodels)","title":"Non-relativistic","text":"","category":"section"},{"location":"components/#SymBoltz.matter","page":"Components (submodels)","title":"SymBoltz.matter","text":"matter(g; name = :m, kwargs...)\n\nCreate a particle species for matter (with equation of state w ~ 0) in the spacetime with metric g.\n\n\n\n\n\n","category":"function"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"m = SymBoltz.matter(g)\nnothing # hide","category":"page"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"<details>\n<summary><h4 style=\"display: inline-block\">Equations</h4></summary>","category":"page"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"equations(m)","category":"page"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"</details>\n<details>\n<summary><h4 style=\"display: inline-block\">Initialization equations</h4></summary>","category":"page"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"initialization_equations(m)","category":"page"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"</details>","category":"page"},{"location":"components/#SymBoltz.cold_dark_matter","page":"Components (submodels)","title":"SymBoltz.cold_dark_matter","text":"cold_dark_matter(g; name = :c, kwargs...)\n\nCreate a particle species for cold dark matter in the spacetime with metric g.\n\n\n\n\n\n","category":"function"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"c = SymBoltz.cold_dark_matter(g)\nnothing # hide","category":"page"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"<details>\n<summary><h4 style=\"display: inline-block\">Equations</h4></summary>","category":"page"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"equations(c)","category":"page"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"</details>\n<details>\n<summary><h4 style=\"display: inline-block\">Initialization equations</h4></summary>","category":"page"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"initialization_equations(c)","category":"page"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"</details>","category":"page"},{"location":"components/#SymBoltz.baryons","page":"Components (submodels)","title":"SymBoltz.baryons","text":"baryons(g; recombination=true, name = :b, kwargs...)\n\nCreate a particle species for baryons in the spacetime with metric g.\n\n\n\n\n\n","category":"function"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"b = SymBoltz.baryons(g)\nnothing # hide","category":"page"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"<details>\n<summary><h4 style=\"display: inline-block\">Equations</h4></summary>","category":"page"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"equations(b)","category":"page"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"</details>\n<details>\n<summary><h4 style=\"display: inline-block\">Initialization equations</h4></summary>","category":"page"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"initialization_equations(b)","category":"page"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"</details>","category":"page"},{"location":"components/#Neutrinos","page":"Components (submodels)","title":"Neutrinos","text":"","category":"section"},{"location":"components/#SymBoltz.massless_neutrinos","page":"Components (submodels)","title":"SymBoltz.massless_neutrinos","text":"massless_neutrinos(g; lmax = 6, name = :ν, kwargs...)\n\nCreate a particle species for massless neutrinos in the spacetime with metric g.\n\n\n\n\n\n","category":"function"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"ν = SymBoltz.massless_neutrinos(g; lmax = 6)\nnothing # hide","category":"page"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"<details>\n<summary><h4 style=\"display: inline-block\">Equations</h4></summary>","category":"page"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"equations(ν)","category":"page"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"</details>\n<details>\n<summary><h4 style=\"display: inline-block\">Initialization equations</h4></summary>","category":"page"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"initialization_equations(ν)","category":"page"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"</details>","category":"page"},{"location":"components/#SymBoltz.massive_neutrinos","page":"Components (submodels)","title":"SymBoltz.massive_neutrinos","text":"massive_neutrinos(g; nx = 5, lmax = 4, name = :h, kwargs...)\n\nCreate a particle species for massive neutrinos in the spacetime with metric g.\n\n\n\n\n\n","category":"function"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"h = SymBoltz.massive_neutrinos(g; nx=4, lmax = 5)\nnothing # hide","category":"page"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"<details>\n<summary><h4 style=\"display: inline-block\">Equations</h4></summary>","category":"page"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"equations(h)","category":"page"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"</details>\n<details>\n<summary><h4 style=\"display: inline-block\">Initialization equations</h4></summary>","category":"page"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"initialization_equations(h)","category":"page"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"</details>","category":"page"},{"location":"components/#Dark-energy","page":"Components (submodels)","title":"Dark energy","text":"","category":"section"},{"location":"components/#SymBoltz.cosmological_constant","page":"Components (submodels)","title":"SymBoltz.cosmological_constant","text":"cosmological_constant(g; name = :Λ, kwargs...)\n\nCreate a particle species for the cosmological constant (with equation of state w ~ -1) in the spacetime with metric g.\n\n\n\n\n\n","category":"function"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"Λ = SymBoltz.cosmological_constant(g)\nnothing # hide","category":"page"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"<details>\n<summary><h4 style=\"display: inline-block\">Equations</h4></summary>","category":"page"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"equations(Λ)","category":"page"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"</details>\n<details>\n<summary><h4 style=\"display: inline-block\">Initialization equations</h4></summary>","category":"page"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"initialization_equations(Λ)","category":"page"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"</details>","category":"page"},{"location":"components/#SymBoltz.w0wa","page":"Components (submodels)","title":"SymBoltz.w0wa","text":"w0wa(g; kwargs...)\n\nCreate a particle species for the w₀-wₐ dark energy (CPL) parametrization in the spacetime with metric g.\n\n\n\n\n\n","category":"function"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"X = SymBoltz.w0wa(g)\nnothing # hide","category":"page"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"<details>\n<summary><h4 style=\"display: inline-block\">Equations</h4></summary>","category":"page"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"equations(X)","category":"page"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"</details>\n<details>\n<summary><h4 style=\"display: inline-block\">Initialization equations</h4></summary>","category":"page"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"initialization_equations(X)","category":"page"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"</details>","category":"page"},{"location":"components/#SymBoltz.quintessence","page":"Components (submodels)","title":"SymBoltz.quintessence","text":"quintessence(g, v; name = :ϕ, kwargs...)\n\nCreate a species for a quintessence scalar field with potential v in the spacetime with metric g.\n\n\n\n\n\n","category":"function"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"@variables ϕ(τ) V(ϕ) V′(ϕ) V′′(ϕ)\nQ = SymBoltz.quintessence(g, V, V′, V′′)\nnothing # hide","category":"page"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"<details>\n<summary><h4 style=\"display: inline-block\">Equations</h4></summary>","category":"page"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"equations(Q)","category":"page"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"</details>\n<details>\n<summary><h4 style=\"display: inline-block\">Initialization equations</h4></summary>","category":"page"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"initialization_equations(Q)","category":"page"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"</details>","category":"page"},{"location":"components/#Curvature-(effective)","page":"Components (submodels)","title":"Curvature (effective)","text":"","category":"section"},{"location":"components/#SymBoltz.curvature","page":"Components (submodels)","title":"SymBoltz.curvature","text":"curvature(g; name = :K, kwargs...)\n\nCreate a species that effectively accounts for curvature in the spacetime with metric g.\n\n\n\n\n\n","category":"function"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"K = SymBoltz.curvature(g)\nnothing # hide","category":"page"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"<details>\n<summary><h4 style=\"display: inline-block\">Equations</h4></summary>","category":"page"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"equations(K)","category":"page"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"</details>\n<details>\n<summary><h4 style=\"display: inline-block\">Initialization equations</h4></summary>","category":"page"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"initialization_equations(K)","category":"page"},{"location":"components/","page":"Components (submodels)","title":"Components (submodels)","text":"</details>","category":"page"},{"location":"comparison/#Comparison-to-CLASS","page":"Comparison to CLASS","title":"Comparison to CLASS","text":"","category":"section"},{"location":"comparison/","page":"Comparison to CLASS","title":"Comparison to CLASS","text":"This page compares results from SymBoltz and the fantastic Einstein-Boltzmann solver CLASS for the ΛCDM model.","category":"page"},{"location":"comparison/","page":"Comparison to CLASS","title":"Comparison to CLASS","text":"<details>\n<summary><h2 style=\"display: inline-block\">Setup</h2></summary>","category":"page"},{"location":"comparison/","page":"Comparison to CLASS","title":"Comparison to CLASS","text":"using SymBoltz\nusing CLASS\nusing DelimitedFiles\nusing DataInterpolations\nusing Unitful, UnitfulAstro\nusing CairoMakie\n\nlmax = 6\nM = w0waCDM(; lmax)\npars = merge(parameters_Planck18(M), Dict(\n    M.X.w0 => -0.9,\n    M.X.wa => 0.1,\n    M.X.cₛ² => 0.9\n))\nh = pars[M.g.h] # needed later\nprob = CosmologyProblem(M, pars)\n\nfunction solve_class(pars, k = nothing)\n    prob = CLASSProblem(\n        \"write_background\" => \"yes\",\n        \"write_thermodynamics\" => \"yes\",\n        \"background_verbose\" => 2,\n        \"output\" => \"mPk, tCl, pCl\", # need one to evolve perturbations\n\n        \"k_output_values\" => isnothing(k) ? \"\" : NoUnits(k / u\"1/Mpc\"),\n        \"ic\" => \"ad\",\n        \"modes\" => \"s\",\n        \"gauge\" => \"newtonian\",\n\n        # metric\n        \"h\" => pars[M.g.h],\n\n        # photons\n        \"T_cmb\" => pars[M.γ.T₀],\n        \"l_max_g\" => lmax,\n        \"l_max_pol_g\" => lmax,\n\n        # baryons\n        \"Omega_b\" => pars[M.b.Ω₀],\n        \"YHe\" => pars[M.b.rec.Yp],\n        \"recombination\" => \"recfast\", # TODO: HyREC\n        \"recfast_Hswitch\" => 1,\n        \"recfast_Heswitch\" => 6,\n        \"reio_parametrization\" => \"reio_camb\",\n\n        # cold dark matter\n        \"Omega_cdm\" => pars[M.c.Ω₀],\n\n        # neutrinos\n        \"N_ur\" => SymBoltz.have(M, :ν) ? pars[M.ν.Neff] : 0.0,\n        \"N_ncdm\" => SymBoltz.have(M, :h) ? 1 : 0,\n        \"m_ncdm\" => SymBoltz.have(M, :h) ? pars[M.h.m_eV] : 0.0, # in eV/c^2\n        \"T_ncdm\" => SymBoltz.have(M, :h) ? (4/11)^(1/3) : 0.0,\n        \"l_max_ur\" => lmax,\n        \"l_max_ncdm\" => lmax,\n\n        # primordial power spectrum\n        \"ln_A_s_1e10\" => pars[M.I.ln_As1e10],\n        \"n_s\" => pars[M.I.ns],\n\n        # w0wa dark energy\n        \"Omega_Lambda\" => 0.0, # unspecified\n        \"w0_fld\" => SymBoltz.have(M, :X) ? pars[M.X.w0] : -1.0,\n        \"wa_fld\" => SymBoltz.have(M, :X) ? pars[M.X.wa] : 0.0,\n        \"cs2_fld\" => SymBoltz.have(M, :X) ? pars[M.X.cₛ²] : 1.0,\n        \"use_ppf\" => SymBoltz.have(M, :X) ? \"no\" : \"yes\", # use full equations (must be yes with CC to prevent crash)\n\n        # other stuff\n        \"Omega_k\" => SymBoltz.have(M, :K) ? pars[M.K.Ω₀] : 0.0, # curvature\n        \"Omega_scf\" => 0.0,\n        \"Omega_dcdmdr\" => 0.0,\n\n        # approximations (see include/precisions.h)\n        \"tight_coupling_trigger_tau_c_over_tau_h\" => 1e-2, # cannot turn off?\n        \"tight_coupling_trigger_tau_c_over_tau_k\" => 1e-3, # cannot turn off\n        \"radiation_streaming_approximation\" => 3, # turns off RSA\n        \"ur_fluid_approximation\" => 3, # turns off UFA\n        \"ncdm_fluid_approximation\" => 3, # turns off NCDM fluid approximation\n\n        #\"l_max_scalars\" => 1500,\n        #\"temperature_contributions\" => \"pol\",\n    )\n    return solve(prob)\nend\n\nk = 1e1 / u\"Mpc\" # 1/Mpc\nsol1 = solve_class(pars, k)\nsol2 = solve(prob, k; ptopts = (alg = SymBoltz.Rodas4P(),)) # looks like lower-precision KenCarp4 and Kvaerno5 \"emulate\" radiation streaming, while higher-precision Rodas5P continues in an exact way\n\nfunction plot_compare(x1s, x2s, y1s, y2s, xlabel, ylabels; lgx=false, lgy=false, common=false, errtype=:auto, errlim=NaN, tol = nothing, kwargs...)\n    if !(ylabels isa AbstractArray)\n        y1s = [y1s]\n        y2s = [y2s]\n        ylabels = [ylabels]\n    end\n\n    xplot(x) = lgx ? log10.(abs.(x)) : x\n    yplot(y) = lgy ? log10.(abs.(y)) : y\n    xlab(x) = lgx ? \"lg(|$x|)\" : x\n    ylab(y) = lgy ? \"lg(|$y|)\" : y\n\n    fig = Figure(width = 800, height = 600)\n    ax1 = Axis(fig[2:3, 1]; xticklabelsvisible = false)\n    ax2 = Axis(fig[4, 1]; xlabel = xlab(xlabel), yminorticks = IntervalsBetween(10), yminorgridvisible = true)\n    maxerr = 0.0\n    xlims = (NaN, NaN)\n    linewidth = 2\n    lines!(ax1, [NaN]; color = :black, linewidth, linestyle = :solid, label = \"CLASS\") # dummy for legend entry\n    lines!(ax1, [NaN]; color = :black, linewidth, linestyle = :dash, label = \"SymBoltz\") # dummy for legend entry\n    for (i, (y1, y2, ylabel)) in enumerate(zip(y1s, y2s, ylabels))\n        x1, x2 = x1s, x2s\n        x1min, x1max = extrema(x1)\n        x2min, x2max = extrema(x2)\n\n        plotx1 = xplot(x1) # https://discourse.julialang.org/t/makie-axis-limits-with-inf/85784\n        plotx2 = xplot(x2)\n        ploty1 = replace!(yplot(y1), -Inf => NaN, Inf => NaN)\n        ploty2 = replace!(yplot(y2), -Inf => NaN, Inf => NaN)\n        color = Makie.wong_colors()[i]\n        lines!(ax1, plotx1, ploty1; color, alpha = 0.6, linewidth, linestyle = :solid)\n        lines!(ax1, plotx2, ploty2; color, alpha = 0.6, linewidth, linestyle = :dash)\n        lines!(ax1, [NaN]; color, linewidth, label = ylab(ylabel)) # dummy for legend entry\n\n        if i == 1\n            xlims = (x1min, x1max) # initialize so not NaN\n        end\n        xlims = if common\n            (max(xlims[1], x1min, x2min), min(xlims[2], x1max, x2max))\n        else\n            (min(xlims[1], x1min, x2min), max(xlims[2], x1max, x2max))\n        end\n\n        xmin = max(x1min, x2min) # need common times to compare error\n        xmax = min(x1max, x2max) # need common times to compare error\n        i1s = xmin .≤ x1 .≤ xmax # select x values in common range and exclude points too close in time (probably due to CLASS switching between approximation schemes)\n        i2s = xmin .≤ x2 .≤ xmax # select x values in common range\n        x1 = x1[i1s]\n        x2 = x2[i2s]\n        y1 = y1[i1s]\n        y2 = y2[i2s]\n        x = x2 # compare ratios at SymBoltz' times\n        y1 = LinearInterpolation(y1, x1; extrapolation = ExtrapolationType.Linear).(x) # TODO: use built-in CosmoloySolution interpolation\n        y2 = LinearInterpolation(y2, x2; extrapolation = ExtrapolationType.Linear).(x)\n\n        !isnothing(tol) && @assert all(isapprox.(y1, y2; atol = tol)) \"$ylabel does not match within absolute tolerance $tol. Maximum difference was $(maximum(abs.(y1.-y2))).\"\n\n        # Compare absolute error if quantity crosses zero, otherwise relative error (unless overridden)\n        abserr = (errtype == :abs) || (errtype == :auto && (any(y1 .<= 0) || any(y2 .<= 0)))\n        if abserr\n            err = y2 .- y1\n            ylabel = \"SymBoltz - CLASS\"\n        else\n            err = y2 ./ y1 .- 1\n            ylabel = \"SymBoltz / CLASS - 1\"\n        end\n        ax2.ylabel = ylabel\n        maxerr = max(maxerr, maximum(abs.(err)))\n        lines!(ax2, xplot(x), err; color, alpha = 1.0, linewidth)\n    end\n\n    # write maximum error like a * 10^b (for integer a and b)\n    if isnan(errlim)\n        b = floor(log10(maxerr))\n        a = ceil(maxerr / 10^b)\n        errlim = a * 10^b\n    end\n    Makie.ylims!(ax2, (-errlim, +errlim))\n\n    xlims = xplot.(xlims) # transform to log?\n    Makie.xlims!(ax1, xlims)\n    Makie.xlims!(ax2, xlims)\n\n    #axislegend(ax1)\n    fig[1, 1] = Legend(fig, ax1; padding = (0, 0, 0, 0), margin = (0, 0, 0, 0), framevisible = false, orientation = :horizontal)\n\n    return fig\nend\nnothing # hide","category":"page"},{"location":"comparison/","page":"Comparison to CLASS","title":"Comparison to CLASS","text":"</details>","category":"page"},{"location":"comparison/#Background","page":"Comparison to CLASS","title":"Background","text":"","category":"section"},{"location":"comparison/#Conformal-time","page":"Comparison to CLASS","title":"Conformal time","text":"","category":"section"},{"location":"comparison/","page":"Comparison to CLASS","title":"Comparison to CLASS","text":"a1 = (1 ./ (sol1[\"background\"][:,\"z\"] .+ 1))\na2 = sol2[M.g.a]\nχ1 = sol1[\"background\"][:,\"conf. time [Mpc]\"][end].-sol1[\"background\"][:,\"conf. time [Mpc]\"]\nχ2 = sol2[M.χ] / (h*SymBoltz.k0)\nplot_compare(a1, a2, χ1, χ2, \"a\", \"χ\"; tol = 1e-2)","category":"page"},{"location":"comparison/#Hubble-function","page":"Comparison to CLASS","title":"Hubble function","text":"","category":"section"},{"location":"comparison/","page":"Comparison to CLASS","title":"Comparison to CLASS","text":"E1 = sol1[\"background\"][:,\"H [1/Mpc]\"]./sol1[\"background\"][end,\"H [1/Mpc]\"]\nE2 = sol2[M.g.E]\nplot_compare(a1, a2, E1, E2, \"a\", \"E\"; lgx=true, lgy=true, tol = 1e9)","category":"page"},{"location":"comparison/#Energy-densities","page":"Comparison to CLASS","title":"Energy densities","text":"","category":"section"},{"location":"comparison/","page":"Comparison to CLASS","title":"Comparison to CLASS","text":"ρ1 = map(s -> sol1[\"background\"][:,\"(.)rho_$s\"], [\"g\", \"ur\", \"cdm\", \"b\", \"fld\", \"ncdm[0]\"])\nρ2 = map(s -> sol2[s.ρ] * 8π/3*(h*SymBoltz.k0)^2, [M.γ, M.ν, M.c, M.b, M.X, M.h])\nplot_compare(a1, a2, ρ1, ρ2, \"a\", [\"ργ\", \"ρb\", \"ρc\", \"ρX\", \"ρν\", \"ρh\"]; lgx=true, lgy=true, tol = 1e16)","category":"page"},{"location":"comparison/#Equations-of-state","page":"Comparison to CLASS","title":"Equations of state","text":"","category":"section"},{"location":"comparison/","page":"Comparison to CLASS","title":"Comparison to CLASS","text":"wh1 = sol1[\"background\"][:,\"(.)p_ncdm[0]\"] ./ sol1[\"background\"][:,\"(.)rho_ncdm[0]\"]\nwh2 = sol2[M.h.w]\nwX1 = sol1[\"background\"][:,\"(.)w_fld\"]\nwX2 = sol2[M.X.w]\nplot_compare(a1, a2, [wh1, wX1], [wh2, wX2], \"a\", [\"wh\", \"wX\"]; lgx=true, tol = 1e-3)","category":"page"},{"location":"comparison/#Photon-baryon-sound-horizon","page":"Comparison to CLASS","title":"Photon-baryon sound horizon","text":"","category":"section"},{"location":"comparison/","page":"Comparison to CLASS","title":"Comparison to CLASS","text":"rs1 = sol1[\"background\"][:,\"comov.snd.hrz.\"]\nrs2 = sound_horizon(sol2) ./ (h*SymBoltz.k0)\nplot_compare(a1, a2, rs1, rs2, \"a\", \"rₛ\"; lgx = true, tol = 0.02)","category":"page"},{"location":"comparison/#Luminosity-distance","page":"Comparison to CLASS","title":"Luminosity distance","text":"","category":"section"},{"location":"comparison/","page":"Comparison to CLASS","title":"Comparison to CLASS","text":"dL1 = sol1[\"background\"][:,\"lum. dist.\"]\ndL2 = SymBoltz.distance_luminosity(sol2) / SymBoltz.Mpc\nplot_compare(a1, a2, dL1, dL2, \"a\", \"dL\"; lgx=true, lgy=true)","category":"page"},{"location":"comparison/#Thermodynamics","page":"Comparison to CLASS","title":"Thermodynamics","text":"","category":"section"},{"location":"comparison/#Optical-depth-derivative","page":"Comparison to CLASS","title":"Optical depth derivative","text":"","category":"section"},{"location":"comparison/","page":"Comparison to CLASS","title":"Comparison to CLASS","text":"a1 = reverse(sol1[\"thermodynamics\"][:,\"scale factor a\"])\na2 = sol2[M.g.a]\ndκ1 = reverse(sol1[\"thermodynamics\"][:,\"kappa' [Mpc^-1]\"])\ndκ2 = -sol2[M.b.rec.κ̇] * (h*SymBoltz.k0)\nplot_compare(a1, a2, dκ1, dκ2, \"a\", \"κ̇\"; lgx=true, lgy=true, tol = 1e4)","category":"page"},{"location":"comparison/#Optical-depth-exponential","page":"Comparison to CLASS","title":"Optical depth exponential","text":"","category":"section"},{"location":"comparison/","page":"Comparison to CLASS","title":"Comparison to CLASS","text":"expmκ1 = reverse(sol1[\"thermodynamics\"][:,\"exp(-kappa)\"])\nexpmκ2 = sol2[M.b.rec.I]\nplot_compare(a1, a2, expmκ1, expmκ2, \"a\", \"exp(-κ)\"; lgx=true, tol = 1e-3)","category":"page"},{"location":"comparison/#Visibility-function","page":"Comparison to CLASS","title":"Visibility function","text":"","category":"section"},{"location":"comparison/","page":"Comparison to CLASS","title":"Comparison to CLASS","text":"v1 = reverse(sol1[\"thermodynamics\"][:,\"g [Mpc^-1]\"])\nv2 = sol2[M.b.rec.v] * (h*SymBoltz.k0)\nplot_compare(a1, a2, v1, v2, \"a\", \"v\"; lgx=true, lgy=false, tol = 1e-4)","category":"page"},{"location":"comparison/#Free-electron-fraction","page":"Comparison to CLASS","title":"Free electron fraction","text":"","category":"section"},{"location":"comparison/","page":"Comparison to CLASS","title":"Comparison to CLASS","text":"Xe1 = reverse(sol1[\"thermodynamics\"][:,\"x_e\"])\nXe2 = sol2[M.b.rec.Xe]\nplot_compare(a1, a2, Xe1, Xe2, \"a\", \"Xe\"; lgx=true, lgy=false, tol = 1e-3)","category":"page"},{"location":"comparison/#Baryon-temperature","page":"Comparison to CLASS","title":"Baryon temperature","text":"","category":"section"},{"location":"comparison/","page":"Comparison to CLASS","title":"Comparison to CLASS","text":"Tb1 = reverse(sol1[\"thermodynamics\"][:,\"Tb [K]\"])\nTb2 = sol2[M.b.rec.Tb]\ndTb1 = reverse(sol1[\"thermodynamics\"][:,\"dTb [K]\"])\ndTb2 = sol2[M.b.rec.DTb] ./ -sol2[M.g.E] # convert my dT/dt̂ to CLASS' dT/dz = -1/H * dT/dt\nplot_compare(a1, a2, [Tb1, dTb1], [Tb2, dTb2], \"a\", [\"Tb\", \"dTb\"]; lgx=true, lgy=true, tol = 1e1)","category":"page"},{"location":"comparison/#Baryon-equation-of-state","page":"Comparison to CLASS","title":"Baryon equation of state","text":"","category":"section"},{"location":"comparison/","page":"Comparison to CLASS","title":"Comparison to CLASS","text":"# baryon equation of state parameter (e.g. https://arxiv.org/pdf/1906.06831 eq. (B10))\nwb1 = reverse(sol1[\"thermodynamics\"][:,\"w_b\"])\nwb2 = sol2[SymBoltz.kB*M.b.rec.Tb/(M.b.rec.μ*SymBoltz.c^2)]\nplot_compare(a1, a2, wb1, wb2, \"a\", \"wb\"; lgx=true, lgy=true, tol = 1e-9)","category":"page"},{"location":"comparison/#Baryon-sound-speed","page":"Comparison to CLASS","title":"Baryon sound speed","text":"","category":"section"},{"location":"comparison/","page":"Comparison to CLASS","title":"Comparison to CLASS","text":"csb²1 = reverse(sol1[\"thermodynamics\"][:,\"c_b^2\"])\ncsb²2 = sol2[M.b.rec.cₛ²]\nplot_compare(a1, a2, csb²1, csb²2, \"a\", \"csb²\"; lgx=true, lgy=true, tol = 1e-8)","category":"page"},{"location":"comparison/#Perturbations","page":"Comparison to CLASS","title":"Perturbations","text":"","category":"section"},{"location":"comparison/#Metric-potentials","page":"Comparison to CLASS","title":"Metric potentials","text":"","category":"section"},{"location":"comparison/","page":"Comparison to CLASS","title":"Comparison to CLASS","text":"a1 = sol1[\"perturbations_k0_s\"][:,\"a\"]\na2 = sol2[1, M.g.a]\nΦ1, Ψ1 = sol1[\"perturbations_k0_s\"][:,\"phi\"], sol1[\"perturbations_k0_s\"][:,\"psi\"]\nΦ2, Ψ2 = sol2[1, M.g.Φ], sol2[1, M.g.Ψ]\nplot_compare(a1, a2, [Φ1, Ψ1], [Φ2, Ψ2], \"a\", [\"Ψ\", \"Φ\"]; lgx=true, tol = 1e-1)","category":"page"},{"location":"comparison/#Energy-overdensities","page":"Comparison to CLASS","title":"Energy overdensities","text":"","category":"section"},{"location":"comparison/","page":"Comparison to CLASS","title":"Comparison to CLASS","text":"δ1 = map(s -> sol1[\"perturbations_k0_s\"][:,\"delta_$s\"], [\"b\", \"cdm\", \"g\", \"ur\", \"ncdm[0]\"])\nδ2 = map(s -> sol2[1, s.δ], [M.b, M.c, M.γ, M.ν, M.h])\nplot_compare(a1, a2, δ1, δ2, \"a\", [\"δb\", \"δc\", \"δγ\", \"δν\", \"δh\"]; lgx=true, lgy=true)","category":"page"},{"location":"comparison/#Momenta","page":"Comparison to CLASS","title":"Momenta","text":"","category":"section"},{"location":"comparison/","page":"Comparison to CLASS","title":"Comparison to CLASS","text":"θ1 = map(s -> sol1[\"perturbations_k0_s\"][:,\"theta_$s\"], [\"b\", \"cdm\", \"g\", \"ur\", \"ncdm[0]\"])\nθ2 = map(s -> sol2[1, s.θ] * (h*SymBoltz.k0), [M.b, M.c, M.γ, M.ν, M.h])\nplot_compare(a1, a2, θ1, θ2, \"a\", [\"θb\", \"θc\", \"θγ\", \"θν\", \"θh\"]; lgx=true, lgy=true)","category":"page"},{"location":"comparison/#Dark-energy-overdensity","page":"Comparison to CLASS","title":"Dark energy overdensity","text":"","category":"section"},{"location":"comparison/","page":"Comparison to CLASS","title":"Comparison to CLASS","text":"δρX1 = sol1[\"perturbations_k0_s\"][:,\"delta_rho_fld\"]\nδρX2 = sol2[1, M.X.δ*M.X.ρ] * 8π/3*(h*SymBoltz.k0)^2\nplot_compare(a1, a2, δρX1, δρX2, \"a\", \"δρX\"; lgx=true, lgy=true, tol = 1e-4)","category":"page"},{"location":"comparison/#Dark-energy-momentum","page":"Comparison to CLASS","title":"Dark energy momentum","text":"","category":"section"},{"location":"comparison/","page":"Comparison to CLASS","title":"Comparison to CLASS","text":"pX1 = sol1[\"perturbations_k0_s\"][:,\"rho_plus_p_theta_fld\"]\npX2 = sol2[1, (M.X.ρ+M.X.P)*M.X.θ * 8π/3*(h*SymBoltz.k0)^3]\nplot_compare(a1, a2, pX1, pX2, \"a\", \"pX\"; lgx=true, lgy=true, tol = 1e-4)","category":"page"},{"location":"comparison/#Shear-stresses","page":"Comparison to CLASS","title":"Shear stresses","text":"","category":"section"},{"location":"comparison/","page":"Comparison to CLASS","title":"Comparison to CLASS","text":"σ1 = [sol1[\"perturbations_k0_s\"][:,\"shear_g\"], sol1[\"perturbations_k0_s\"][:,\"shear_ur\"]]\nσ2 = [sol2[1, M.γ.σ], sol2[1, M.ν.F[2]/2]]\nplot_compare(a1, a2, σ1, σ2, \"a\", [\"σγ\", \"σν\"]; lgx=true, tol = 1e-0)","category":"page"},{"location":"comparison/#Polarization","page":"Comparison to CLASS","title":"Polarization","text":"","category":"section"},{"location":"comparison/","page":"Comparison to CLASS","title":"Comparison to CLASS","text":"P1 = map(n -> sol1[\"perturbations_k0_s\"][:,\"pol$(n)_g\"], 0:2)\nP2 = [sol2[1, var] for var in [M.γ.G0, M.γ.G[1], M.γ.G[2]]]\nplot_compare(a1, a2, P1, P2, \"a\", [\"P0\", \"P1\", \"P2\"]; lgx=true, tol = 1e-1)","category":"page"},{"location":"comparison/#Matter-power-spectrum","page":"Comparison to CLASS","title":"Matter power spectrum","text":"","category":"section"},{"location":"comparison/","page":"Comparison to CLASS","title":"Comparison to CLASS","text":"function P_class(pars)\n    sol = solve_class(pars)\n    h = pars[M.g.h]\n    k = sol[\"pk\"][:,\"k (h/Mpc)\"] * h\n    P = sol[\"pk\"][:,\"P (Mpc/h)^3\"] / h^3\n    return k, P\nend\nfunction P_class(k, pars)\n    k′, P′ = P_class(pars)\n    P = exp.(LinearInterpolation(log.(P′), log.(k′)).(log.(k)))\n    return P\nend\nfunction P_symboltz(k, pars)\n    prob′ = parameter_updater(prob, collect(keys(pars)))(collect(values(pars))) # TODO: move outside; common for Pk and Cl\n    P = spectrum_matter(prob′, k / u\"Mpc\") / u\"Mpc^3\"\n    return P\nend\nk, P1 = P_class(pars)\nP2 = P_symboltz(k, pars)\nplot_compare(k, k, P1, P2, \"k/Mpc⁻¹\", \"P/Mpc³\"; lgx = true, lgy = true, tol = 1e2)","category":"page"},{"location":"comparison/","page":"Comparison to CLASS","title":"Comparison to CLASS","text":"using ForwardDiff, FiniteDiff\n\nk = 10 .^ range(-3, 0, length=100) # 1/Mpc\nfunction plot_compare_P_diff(par, val; relstep = 1e-2, kwargs...)\n    out = zeros(length(k))\n    f = function(out, logval)\n        val = exp(logval)\n        out .= log.(P_class(k, merge(pars, Dict(par => val))))\n        return out\n    end\n    Δt1 = @elapsed ∂logP1_∂logθ = FiniteDiff.finite_difference_gradient!(out, f, log(val), Val{:central}; relstep)\n    println(\"Computed CLASS derivatives in $Δt1 seconds\")\n    Δt2 = @elapsed ∂logP2_∂logθ = ForwardDiff.derivative(logval -> log.(P_symboltz(k, Dict(par => exp(logval)))), log(val))\n    println(\"Computed SymBoltz derivatives in $Δt2 seconds\")\n    return plot_compare(k, k, ∂logP1_∂logθ, ∂logP2_∂logθ, \"k\", \"∂(log(P))/∂(log($(replace(string(par), \"₊\" => \".\"))))\"; lgx = true, kwargs...)\nend\n\n#∂logP1_∂θ = FiniteDiff.finite_difference_jacobian(θ -> log.(P_class(merge(pars, Dict(diffpars .=> θ)))[2]), θ, Val{:central}; relstep = 1e-4) # hide\n#∂logP2_∂θ = ForwardDiff.jacobian(θ -> log.(P_symboltz(k, Dict(diffpars .=> θ))[2]), θ) # hide\n#plot_compare(k, k, eachcol(∂logP1_∂θ), eachcol(∂logP2_∂θ), \"k\", [\"∂(lg(P))/∂($par)\" for par in [\"Ωc0\", \"Ωb0\", \"h\"]]; lgx = true) # hide\n\nplot_compare_P_diff(M.c.Ω₀, pars[M.c.Ω₀]; relstep = 1e-3, tol = 1e-1) # smaller relstep is noisier","category":"page"},{"location":"comparison/","page":"Comparison to CLASS","title":"Comparison to CLASS","text":"plot_compare_P_diff(M.b.Ω₀, pars[M.b.Ω₀]; relstep = 1e-3, tol = 1e-1) # smaller relstep is noisier","category":"page"},{"location":"comparison/","page":"Comparison to CLASS","title":"Comparison to CLASS","text":"plot_compare_P_diff(M.g.h, pars[M.g.h]; relstep = 1e-3, tol = 1e-1) # smaller relstep is noisier","category":"page"},{"location":"comparison/#CMB-power-spectrum","page":"Comparison to CLASS","title":"CMB power spectrum","text":"","category":"section"},{"location":"comparison/","page":"Comparison to CLASS","title":"Comparison to CLASS","text":"function Dl_class(modes, l, pars)\n    sol = solve_class(pars)\n    lout = sol[\"cl\"][:,\"l\"]\n    Dl = [sol[\"cl\"][:,string(mode)] for mode in modes]\n    i = findall(l′ -> l′ in l, lout)\n    Dl = [Dl[j][i] for j in eachindex(modes)]\n    return stack(Dl)\nend\nfunction Dl_symboltz(modes, l, pars; kwargs...)\n    prob′ = parameter_updater(prob, collect(keys(pars)))(collect(values(pars)))\n    return spectrum_cmb(modes, prob′, l; normalization = :Dl, kwargs...)\nend\n\nl = 20:20:2000 # CLASS default is lmax = 2500\nDl1 = Dl_class([:TT, :TE, :EE], l, pars)\nDl2 = Dl_symboltz([:TT, :TE, :EE], l, pars)\nplot_compare(l, l, Dl1[:, 1], Dl2[:, 1], \"l\", \"Dₗ(TT)\"; tol = 7e-13)","category":"page"},{"location":"comparison/","page":"Comparison to CLASS","title":"Comparison to CLASS","text":"plot_compare(l, l, Dl1[:, 2], Dl2[:, 2], \"l\", \"Dₗ(TE)\"; tol = 8e-14)","category":"page"},{"location":"comparison/","page":"Comparison to CLASS","title":"Comparison to CLASS","text":"plot_compare(l, l, Dl1[:, 3], Dl2[:, 3], \"l\", \"Dₗ(EE)\"; tol = 2e-14)","category":"page"},{"location":"comparison/","page":"Comparison to CLASS","title":"Comparison to CLASS","text":"diffpars = [M.c.Ω₀, M.b.Ω₀, M.g.h]\nθ = [pars[par] for par in diffpars]\nmodes = [:TT, :TE, :EE]\n\nΔt1 = @elapsed ∂Dl1_∂θ = FiniteDiff.finite_difference_jacobian(θ -> Dl_class(modes, l, merge(pars, Dict(diffpars .=> θ))), θ, Val{:central}; relstep = 1e-3)\nprintln(\"Computed CLASS derivatives in $Δt1 seconds\")\nΔt2 = @elapsed ∂Dl2_∂θ = ForwardDiff.jacobian(θ -> Dl_symboltz(modes, l, Dict(diffpars .=> θ)), θ)\nprintln(\"Computed SymBoltz derivatives in $Δt2 seconds\")\n\n# returned matrices have size (length(l)*length(modes), length(diffpars)); reshape to (length(l), length(modes), length(diffpars))\n∂Dl1_∂θ_3d = reshape(∂Dl1_∂θ, (length(l), length(modes), length(diffpars)))\n∂Dl2_∂θ_3d = reshape(∂Dl2_∂θ, (length(l), length(modes), length(diffpars)))\n\nplot_compare(l, l, eachcol(∂Dl1_∂θ_3d[:,1,:]), eachcol(∂Dl2_∂θ_3d[:,1,:]), \"l\", [\"∂(Dₗ)/∂($(replace(string(par), \"₊\" => \".\"))) (TT)\" for par in diffpars]; tol = 1e-10)","category":"page"},{"location":"comparison/","page":"Comparison to CLASS","title":"Comparison to CLASS","text":"plot_compare(l, l, eachcol(∂Dl1_∂θ_3d[:,2,:]), eachcol(∂Dl2_∂θ_3d[:,2,:]), \"l\", [\"∂(Dₗ)/∂($(replace(string(par), \"₊\" => \".\"))) (TE)\" for par in diffpars]; tol = 1e-11)","category":"page"},{"location":"comparison/","page":"Comparison to CLASS","title":"Comparison to CLASS","text":"plot_compare(l, l, eachcol(∂Dl1_∂θ_3d[:,3,:]), eachcol(∂Dl2_∂θ_3d[:,3,:]), \"l\", [\"∂(Dₗ)/∂($(replace(string(par), \"₊\" => \".\"))) (EE)\" for par in diffpars]; tol = 1e-12)","category":"page"},{"location":"extended_models/#Extending-models","page":"Extending models","title":"Extending models","text":"","category":"section"},{"location":"extended_models/","page":"Extending models","title":"Extending models","text":"This tutorial shows how to create extended (beyond-ΛCDM) models. As a simple example, we replace the cosmological constant with equation of state w(τ) = -1 by w₀wₐ dark energy with equation of state","category":"page"},{"location":"extended_models/","page":"Extending models","title":"Extending models","text":"w(τ) = fracP(τ)ρ(τ) = w_0 + w_a (1 - a(τ))","category":"page"},{"location":"extended_models/","page":"Extending models","title":"Extending models","text":"turning the ΛCDM model into the w₀wₐCDM model, as suggested by Chevallier, Polarski (2000) and Linder (2002).","category":"page"},{"location":"extended_models/","page":"Extending models","title":"Extending models","text":"SymBoltz represents each component of the Einstein-Boltzmann equations as a System. These are effectively incomplete \"chunks\" of logically related parameters, variables, equations and initial conditions that are composed together into a complete cosmological model. A cosmological model can be modified by adding or replacing components.","category":"page"},{"location":"extended_models/#1.-Create-the-reference-model","page":"Extending models","title":"1. Create the reference model","text":"","category":"section"},{"location":"extended_models/","page":"Extending models","title":"Extending models","text":"First, we create the reference model that is to be extended. We will modify the standard ΛCDM model:","category":"page"},{"location":"extended_models/","page":"Extending models","title":"Extending models","text":"using SymBoltz\nM1 = ΛCDM()\nhierarchy(M1; describe = true)","category":"page"},{"location":"extended_models/","page":"Extending models","title":"Extending models","text":"Everything belonging to the cosmological constant species is stored in the component M1.Λ:","category":"page"},{"location":"extended_models/","page":"Extending models","title":"Extending models","text":"equations(M1.Λ)","category":"page"},{"location":"extended_models/","page":"Extending models","title":"Extending models","text":"This is what we will replace.","category":"page"},{"location":"extended_models/#2.-Create-the-extended-component","page":"Extending models","title":"2. Create the extended component","text":"","category":"section"},{"location":"extended_models/","page":"Extending models","title":"Extending models","text":"The background continuity equation ρ(τ) = -3 H(τ)  ρ(τ)  (1 + w(τ)) can be solved analytically with the w₀wₐ equation of state and the ansatz","category":"page"},{"location":"extended_models/","page":"Extending models","title":"Extending models","text":"ρ(τ) = ρ(τ₀)  a(τ)ᵐ exp(n (1 - a(τ)))","category":"page"},{"location":"extended_models/","page":"Extending models","title":"Extending models","text":"giving m = -3 (1 + w₀ + wₐ) and n = -3 wₐ. The perturbation equations are","category":"page"},{"location":"extended_models/","page":"Extending models","title":"Extending models","text":"beginaligned\nδ = -(1 + w) (θ - 3 Φ) - 3 fracaa (c_s^2 - w) δ \nθ = -fracaa (1 - 3w) θ - fracw1+w θ + fracc_s^21+w k^2 δ - k^2 σ + k^2 Ψ\nendaligned","category":"page"},{"location":"extended_models/","page":"Extending models","title":"Extending models","text":"with (adiabatic) initial conditions δ = -frac32 (1+w) Ψ and θ = frac12 k^2 τ Ψ, following Bertschinger and Ma (equation 30).","category":"page"},{"location":"extended_models/","page":"Extending models","title":"Extending models","text":"Next, we must simply pack this into a symbolic component that represents the w₀wₐ dark energy species:","category":"page"},{"location":"extended_models/","page":"Extending models","title":"Extending models","text":"g, τ, k = M1.g, M1.τ, M1.k # reuse metric of original model\nD = Differential(τ)\n\n# 1. Create parameters (will resurface as tunable numbers in the full model)\npars = @parameters w₀ wₐ cₛ² Ω₀\n\n# 2. Create variables\nvars = @variables ρ(τ) P(τ) w(τ) δ(τ, k) θ(τ, k) σ(τ, k)\n\n# 3. Specify equations (~ means equality in ModelingToolkit)\neqs = [\n    # Background equations\n    w ~ w₀ + wₐ * (1 - g.a) # equation of state\n    ρ ~ 3/(8*Num(π))*Ω₀ * g.a^(-3*(1+w₀+wₐ)) # D(ρ) ~ -3 * g.ℰ * ρ * (1 + w) # energy density (ρ₀ => 3/(8*Num(π)) * exp(+3*wₐ) * Ω₀)\n    P ~ w * ρ # pressure\n\n    # Perturbation equations\n    D(δ) ~ -(1 + w) * (θ - 3*g.Φ) - 3 * g.ℰ * (cₛ² - w) * δ # energy overdensity\n    D(θ) ~ -g.ℰ * (1 - 3*w) * θ - D(w) / (1 + w) * θ + cₛ² / (1 + w) * k^2 * δ - k^2 * σ + k^2 * g.Ψ # momentum\n    σ ~ 0 # shear stress\n]\n\n# 4. Specify initial conditions (for perturbations)\ninitialization_eqs = [\n    δ ~ -3/2 * (1+w) * g.Ψ\n    θ ~ 1/2 * (k^2/g.ℰ) * g.Ψ\n]\n\n# 5. Pack into an ODE system called \"X\"\ndescription = \"w₀wₐ (CPL) dynamical dark energy\"\n@named X = System(eqs, τ, vars, pars; initialization_eqs, description)","category":"page"},{"location":"extended_models/","page":"Extending models","title":"Extending models","text":"Note that the w₀wₐ component only knows about itself (and the metric), but is completely unaware of the theory of gravity, other species and other components. Its \"job\" is only to expose the variables like ρ, P, δ and σ that source the Einstein equations. This connection is made when the component is used to create a full cosmological model, as we will do next.","category":"page"},{"location":"extended_models/#3.-Create-the-extended-model","page":"Extending models","title":"3. Create the extended model","text":"","category":"section"},{"location":"extended_models/","page":"Extending models","title":"Extending models","text":"Finally, we create a new ΛCDM model, but replace Λ by X, and call it the w0waCDM model:","category":"page"},{"location":"extended_models/","page":"Extending models","title":"Extending models","text":"M2 = ΛCDM(Λ = X, name = :w0waCDM)\nhierarchy(M2; describe = true)","category":"page"},{"location":"extended_models/","page":"Extending models","title":"Extending models","text":"Now M2.Λ no longer exists, but M2.X contains our new dark energy species:","category":"page"},{"location":"extended_models/","page":"Extending models","title":"Extending models","text":"equations(M2.X)","category":"page"},{"location":"extended_models/#Solve-and-compare-the-models","page":"Extending models","title":"Solve and compare the models","text":"","category":"section"},{"location":"extended_models/","page":"Extending models","title":"Extending models","text":"To test, let us set some parameters and solve both models with one perturbation mode. For the ΛCDM model:","category":"page"},{"location":"extended_models/","page":"Extending models","title":"Extending models","text":"θ1 = SymBoltz.parameters_Planck18(M1)\nprob1 = CosmologyProblem(M1, θ1)\nks = 1.0\nsol1 = solve(prob1, ks)","category":"page"},{"location":"extended_models/","page":"Extending models","title":"Extending models","text":"And for the w₀wₐCDM model:","category":"page"},{"location":"extended_models/","page":"Extending models","title":"Extending models","text":"θ2 = merge(θ1, Dict(\n    M2.X.w₀ => -0.9,\n    M2.X.wₐ => 0.2,\n    M2.X.cₛ² => 1.0\n))\nprob2 = CosmologyProblem(M2, θ2)\nsol2 = solve(prob2, ks)","category":"page"},{"location":"extended_models/","page":"Extending models","title":"Extending models","text":"Let us compare H(τ) and Ψ(kτ) at equal scale factors a(τ):","category":"page"},{"location":"extended_models/","page":"Extending models","title":"Extending models","text":"lgas = range(-3, 0, length=500) # log10(a)\nH1s = sol1(M1.g.H, log10(M1.g.a) => lgas)\nH2s = sol2(M2.g.H, log10(M2.g.a) => lgas)\nΨ1s = sol1(M1.g.Ψ, log10(M1.g.a) => lgas, ks)\nΨ2s = sol2(M2.g.Ψ, log10(M2.g.a) => lgas, ks)\n\nusing Plots\nplot(lgas, H2s ./ H1s; xlabel = \"lg(a)\", label = \"H₂ / H₁\")\nplot!(lgas, Ψ1s ./ Ψ2s; xlabel = \"lg(a)\", label = \"Ψ₂ / Ψ₁\")","category":"page"},{"location":"benchmarks/#Performance-and-benchmarks","page":"Performance and benchmarks","title":"Performance and benchmarks","text":"","category":"section"},{"location":"benchmarks/","page":"Performance and benchmarks","title":"Performance and benchmarks","text":"note: Note\nThis page is a work in progress.","category":"page"},{"location":"benchmarks/","page":"Performance and benchmarks","title":"Performance and benchmarks","text":"using MKL, SymBoltz, OrdinaryDiffEq, BenchmarkTools, Plots, BenchmarkPlots, StatsPlots, InteractiveUtils\nM = SymBoltz.ΛCDM(ν = nothing, K = nothing, h = nothing)\npars = SymBoltz.parameters_Planck18(M) # TODO: faster if i set ΩΛ0 explicitly?\nprob = CosmologyProblem(M, pars)\nks = 10 .^ range(-1, 4, length = 100)\nbenchmarks = BenchmarkGroup()\n\nusing Dates\nprintln(\"Current time: \", now())\nprint(sprint(InteractiveUtils.versioninfo)) # show computer information\nnothing # hide","category":"page"},{"location":"benchmarks/#Parallelize-perturbations","page":"Performance and benchmarks","title":"Parallelize perturbations","text":"","category":"section"},{"location":"benchmarks/","page":"Performance and benchmarks","title":"Performance and benchmarks","text":"By default, SymBoltz parallelizes integration of different perturbation modes k with multithreading. This is a standard technique in Boltzmann solvers, as linear perturbation modes are mathematically independent. It leads to a performance improvement depending on the number of threads available, but can be turned off, for example if your application permits parallelization at a higher level:","category":"page"},{"location":"benchmarks/","page":"Performance and benchmarks","title":"Performance and benchmarks","text":"using Base.Threads\nfor thread in [true, false]\n    label = thread ? \"$(nthreads()) threads\" : \"1 thread\"\n    benchmarks[\"thread\"][label] = @benchmarkable $solve($prob, $ks; thread = $thread)\nend\nresults = run(benchmarks[\"thread\"]; verbose = true)\nplot(results; size = (800, 400))","category":"page"},{"location":"benchmarks/#Linear-algebra-backend","page":"Performance and benchmarks","title":"Linear algebra backend","text":"","category":"section"},{"location":"benchmarks/","page":"Performance and benchmarks","title":"Performance and benchmarks","text":"By default, SymBoltz uses implicit ODE solvers to integrate approximation-free stiff equations. Unlike explicit solvers (used in Boltzmann solvers with approximations), they are often bottlenecked by linear algebra operations on the Jacobian matrix at every time step. Choosing an optimal linear matrix solver and/or switching to an alternative BLAS library (such as MKL or AppleAccelerate over Julia's default OpenBLAS backend) can therefore improve performance. This is dependent on your hardware!","category":"page"},{"location":"benchmarks/","page":"Performance and benchmarks","title":"Performance and benchmarks","text":"Moreover, both BLAS and SymBoltz use multi-threading to parallellize linear algebra operations and integration of indendent perturbation modes, respectively. These can conflict. For best multi-threading performance it is recommended to restrict BLAS to a single thread and parallellize only the integration of perturbations.","category":"page"},{"location":"benchmarks/","page":"Performance and benchmarks","title":"Performance and benchmarks","text":"linsolves = [\n    SymBoltz.LUFactorization()\n    SymBoltz.RFLUFactorization()\n    SymBoltz.MKLLUFactorization()\n    SymBoltz.KrylovJL_GMRES(rtol = 1e-3, atol = 1e-3)\n]\nfor linsolve in linsolves\n    ptopts = (alg = KenCarp4(; linsolve), reltol = 1e-8)\n    benchmarks[\"linsolve\"][nameof(typeof(linsolve))] = @benchmarkable $solve($prob, $ks; ptopts = $ptopts)\nend\nresults = run(benchmarks[\"linsolve\"]; verbose = true)\nplot(results; size = (800, 400))","category":"page"},{"location":"benchmarks/#Background-solver-options","page":"Performance and benchmarks","title":"Background solver options","text":"","category":"section"},{"location":"benchmarks/","page":"Performance and benchmarks","title":"Performance and benchmarks","text":"bgalgs = [\n    Rodas4()\n    Rodas5()\n    Rodas4P()\n    Rodas5P()\n]\nfor alg in bgalgs\n    bgopts = (alg = alg, reltol = 1e-9)\n    benchmarks[\"bgsolver\"][nameof(typeof(alg))] = @benchmarkable $solve($prob; bgopts = $bgopts)\nend\nresults = run(benchmarks[\"bgsolver\"]; verbose = true)\nplot(results; size = (800, 400))","category":"page"},{"location":"benchmarks/#Perturbation-ODE-solver","page":"Performance and benchmarks","title":"Perturbation ODE solver","text":"","category":"section"},{"location":"benchmarks/","page":"Performance and benchmarks","title":"Performance and benchmarks","text":"# TODO: test accuracy; work-precision diagram? # hide\n# TODO: test different nlsolve # hide\n# TODO: use BenchmarkTools.BenchmarkGroup # hide\nptalgs = [\n    TRBDF2()\n    KenCarp4()\n    KenCarp47()\n    Kvaerno5()\n    Rodas5P()\n    Rodas5()\n    Rodas4()\n    Rodas4P()\n    QNDF()\n]\nfor alg in ptalgs\n    ptopts = (alg = alg, reltol = 1e-5)\n    benchmarks[\"ptsolver\"][nameof(typeof(alg))] = @benchmarkable $solve($prob, $ks; ptopts = $ptopts)\nend\nresults = run(benchmarks[\"ptsolver\"]; verbose = true)\nplot(results; size = (800, 400))","category":"page"},{"location":"benchmarks/#Perturbations-Jacobian-method","page":"Performance and benchmarks","title":"Perturbations Jacobian method","text":"","category":"section"},{"location":"benchmarks/","page":"Performance and benchmarks","title":"Performance and benchmarks","text":"probs = [\n    CosmologyProblem(M, pars; jac = false)\n    CosmologyProblem(M, pars; jac = true)\n]\nfor prob in probs\n    for autodiff in (true, false)\n        name = isnothing(prob.bg.f.jac) ? \"Numerical\" : \"Symbolic\"\n        name *= (autodiff ? \" (auto. diff.)\" : \" (fin. diff.)\")\n        bgopts = (alg = SymBoltz.Rodas4P(autodiff = autodiff), reltol = 1e-9)\n        ptopts = (alg = SymBoltz.KenCarp4(autodiff = autodiff), reltol = 1e-8)\n        benchmarks[\"jacobian\"][name] = @benchmarkable $solve($prob, $ks; bgopts = $bgopts, ptopts = $ptopts)\n    end\nend\nresults = run(benchmarks[\"jacobian\"]; verbose = true)\nplot(results; size = (800, 400))","category":"page"},{"location":"solve/#Solving-models","page":"Solving models","title":"Solving models","text":"","category":"section"},{"location":"solve/","page":"Solving models","title":"Solving models","text":"First create a symbolic cosmological model:","category":"page"},{"location":"solve/","page":"Solving models","title":"Solving models","text":"using SymBoltz\nM = SymBoltz.ΛCDM()\nnothing # hide","category":"page"},{"location":"solve/#Creating-the-problem","page":"Solving models","title":"Creating the problem","text":"","category":"section"},{"location":"solve/","page":"Solving models","title":"Solving models","text":"Once the symbolic cosmological model M has been constructed, it can be turned into a numerical problem: For example:","category":"page"},{"location":"solve/","page":"Solving models","title":"Solving models","text":"pars = SymBoltz.parameters_Planck18(M)\nprob = CosmologyProblem(M, pars)","category":"page"},{"location":"solve/#SymBoltz.CosmologyProblem","page":"Solving models","title":"SymBoltz.CosmologyProblem","text":"CosmologyProblem(\n    M::System, pars::Dict, shoot_pars = Dict(), shoot_conditions = [];\n    ivspan = (0.0, 100.0), bg = true, pt = true, spline = true, debug = false, fully_determined = true, jac = false, kwargs...\n)\n\nCreate a numerical cosmological problem from the model M with parameters pars. Optionally, the shooting method determines the parameters shoot_pars (mapped to initial guesses) such that the equations shoot_conditions are satisfied at the final time.\n\nIf bg and pt, the model is split into the background and perturbations stages. If spline is a Bool, it decides whether all background unknowns in the perturbations system are replaced by splines. If spline is a Vector, it rather decides which (unknown and observed) variables are splined.\n\n\n\n\n\n","category":"type"},{"location":"solve/#Updating-the-parameters","page":"Solving models","title":"Updating the parameters","text":"","category":"section"},{"location":"solve/","page":"Solving models","title":"Solving models","text":"Constructing a CosmologyProblem is an expensive operation that compiles all the symbolics down to numerics. It is not necessary to repeat this just to update parameter values. To do so, use the function parameter_updater that returns a function that quickly creates new problems with updated parameter values:","category":"page"},{"location":"solve/","page":"Solving models","title":"Solving models","text":"probmaker = parameter_updater(prob, [M.g.h, M.c.Ω₀]) # fast factory function\nprob = probmaker([0.70, 0.27]) # create updated problem","category":"page"},{"location":"solve/#SymBoltz.parameter_updater","page":"Solving models","title":"SymBoltz.parameter_updater","text":"parameter_updater(prob::CosmologyProblem, idxs; kwargs...)\n\nCreate and return a function that updates the symbolic parameters idxs of the cosmological problem prob. The returned function is called with numerical values (in the same order as idxs) and returns a new problem with the updated parameters.\n\n\n\n\n\n","category":"function"},{"location":"solve/#Solving-the-problem","page":"Solving models","title":"Solving the problem","text":"","category":"section"},{"location":"solve/","page":"Solving models","title":"Solving models","text":"The (updated) problem can now be solved for some wavenumbers:","category":"page"},{"location":"solve/","page":"Solving models","title":"Solving models","text":"using Unitful, UnitfulAstro\nks = 10 .^ range(-5, +1, length=100) / u\"Mpc\"\nsol = solve(prob, ks)","category":"page"},{"location":"solve/#CommonSolve.solve-Tuple{CosmologyProblem, AbstractArray}","page":"Solving models","title":"CommonSolve.solve","text":"CommonSolve.solve(args...; kwargs...)\n\nSolves an equation or other mathematical problem using the algorithm specified in the arguments. Generally, the interface is:\n\nCommonSolve.solve(prob::ProblemType,alg::SolverType; kwargs...)::SolutionType\n\nwhere the keyword arguments are uniform across all choices of algorithms.\n\nBy default, solve defaults to using solve! on the iterator form, i.e.:\n\nsolve(args...; kwargs...) = solve!(init(args...; kwargs...))\n\n\n\n\n\nfunction solve(\n    prob::CosmologyProblem, ks::Union{Nothing, AbstractArray} = nothing;\n    bgopts = (alg = Rodas4P(), reltol = 1e-9, abstol = 1e-9),\n    ptopts = (alg = KenCarp4(), reltol = 1e-8, abstol = 1e-8),\n    shootopts = (alg = NewtonRaphson(), abstol = 1e-5),\n    thread = true, verbose = false, kwargs...\n)\n\nSolve the cosmological problem prob up to the perturbative level with wavenumbers ks (or only to the background level if it is empty). The options bgopts and ptopts are passed to the background and perturbations ODE solve() calls, and shootopts to the shooting method nonlinear solve(). If threads, integration over independent perturbation modes are parallellized.\n\n\n\n\n\n","category":"method"},{"location":"solve/#Accessing-the-solution","page":"Solving models","title":"Accessing the solution","text":"","category":"section"},{"location":"solve/","page":"Solving models","title":"Solving models","text":"The returned solution sol can be conveniently accessed to obtain any variable y of the model M:","category":"page"},{"location":"solve/","page":"Solving models","title":"Solving models","text":"sol(y, τ) returns the background variable(s) y(τ) as a function of conformal time(s) τ. It interpolates between time points using the ODE solver's custom-tailored interpolator.\nsol(y, τ, k) returns the perturbation variable(s) y(τk) as a function of the wavenumber(s) k and conformal time(s) τ. It also interpolates linearly between the logarithms of the wavenumbers passed to solve.","category":"page"},{"location":"solve/","page":"Solving models","title":"Solving models","text":"Note that y can be any symbolic variables in the model M, and even expressions thereof. Unknown variables are part of the state vector integrated by the ODE solver, and are returned directly from its solution. Observed variables or expressions are functions of the unknowns, and are automatically calculated from the equations that define them in the symbolic model. For example:","category":"page"},{"location":"solve/","page":"Solving models","title":"Solving models","text":"# TODO: document callable solution when this is fixed: https://github.com/JuliaDocs/Documenter.jl/issues/558 # hide\nτs = sol[M.τ] # get time points used in the background solution\nks = [1e-3, 1e-2, 1e-1, 1e0] / u\"Mpc\" # wavenumbers\nas = sol(M.g.a, τs) # scale factors\nΩms = sol((M.b.ρ + M.c.ρ) / M.G.ρ, τs) # matter-to-total density ratios\nκs = sol(M.b.rec.κ, τs) # optical depths\nΦs = sol(M.g.Φ, τs, ks) # metric potentials\nΦs_over_Ψs = sol(M.g.Φ / M.g.Ψ, τs, ks) # ratio between metric potentials\nnothing # hide","category":"page"},{"location":"solve/#Plotting-the-solution","page":"Solving models","title":"Plotting the solution","text":"","category":"section"},{"location":"solve/","page":"Solving models","title":"Solving models","text":"SymBoltz.jl includes plot recipes for easily visualizing the solution. It works similarly to the solution accessing: call plot(sol, [wavenumber(s),] x_expr, y_expr) to plot y_expr as a function of x_expr. For example, to plot some of the same quantities that we obtained above:","category":"page"},{"location":"solve/","page":"Solving models","title":"Solving models","text":"using Plots\np1 = plot(sol, log10(M.g.a), (M.b.ρ + M.c.ρ) / M.G.ρ)\np2 = plot(sol, log10(M.g.a), log10(abs(M.b.rec.κ)))\np3 = plot(sol, log10(M.g.a), M.g.Φ / M.g.Ψ, ks[1:3]) # exclude last k, where Φ and Ψ cross 0\nplot(p1, p2, p3, layout=(3, 1), size=(600, 800))","category":"page"},{"location":"solve/","page":"Solving models","title":"Solving models","text":"More examples are shown on the models page.","category":"page"},{"location":"solve/#Solve-background-and-perturbations-directly","page":"Solving models","title":"Solve background and perturbations directly","text":"","category":"section"},{"location":"solve/","page":"Solving models","title":"Solving models","text":"For lower-level control, you can solve the background and perturbations separately:","category":"page"},{"location":"solve/#SymBoltz.solvebg","page":"Solving models","title":"SymBoltz.solvebg","text":"solvebg(bgprob::ODEProblem; alg = Rodas4P(), reltol = 1e-9, abstol = 1e-9, verbose = false, kwargs...)\n\nSolve the background cosmology problem bgprob.\n\n\n\n\n\n","category":"function"},{"location":"solve/#SymBoltz.solvept","page":"Solving models","title":"SymBoltz.solvept","text":"solvept(ptprob::ODEProblem, bgsol::ODESolution, ks::AbstractArray, var2spl::Dict; alg = KenCarp4(), reltol = 1e-8, abstol = 1e-8, output_func = (sol, i) -> (sol, false), thread = true, verbose = false, kwargs...)\n\nSolve the perturbation cosmology problem ptprob with wavenumbers ks. A background solution bgsol must be passed (see solvebg), and a dictionary var2spl that maps background variables to spline parameters in the perturbation problem. If thread and Julia is running with multiple threads, the solution of independent wavenumbers is parallellized. The return value is an EnsembleSolution over all ks.\n\n\n\n\n\n","category":"function"},{"location":"solve/#Choice-of-ODE-solver","page":"Solving models","title":"Choice of ODE solver","text":"","category":"section"},{"location":"solve/","page":"Solving models","title":"Solving models","text":"In principle, models can be solved with any DifferentialEquations.jl ODE solver. But most cosmological models have very stiff Einstein-Boltzmann equations that can only be solved by implicit solvers, while explicit solvers usually fail. For the standard ΛCDM model, some good solvers are:","category":"page"},{"location":"solve/","page":"Solving models","title":"Solving models","text":"Rodas4P: Slow for large systems. Very accurate. Handles extreme stiffness. Default background solver.\nRodas5P: Slow for large systems. Very accurate. Handles severe stiffness.\nKenCarp4 (and KenCarp47): Fast. Handles medium stiffness. Default perturbation solver.\nKvaerno5: Behaves similar to KenCarp4. Slightly more accurate. Slightly slower.\nTRBDF2: Very fast. Decent accuracy. Handles severe stiffness.","category":"page"},{"location":"solve/","page":"Solving models","title":"Solving models","text":"See also the solver benchmarks.","category":"page"},{"location":"models/#Cosmologies-(full-models)","page":"Cosmologies (full models)","title":"Cosmologies (full models)","text":"","category":"section"},{"location":"models/#Free-radiation,-matter-and-cosmological-constant-(RMΛ)","page":"Cosmologies (full models)","title":"Free radiation, matter and cosmological constant (RMΛ)","text":"","category":"section"},{"location":"models/#SymBoltz.RMΛ","page":"Cosmologies (full models)","title":"SymBoltz.RMΛ","text":"RMΛ(;\n    acceleration = false,\n    adiabatic = true,\n    g = metric(),\n    r = radiation(g; adiabatic),\n    m = matter(g; adiabatic),\n    Λ = cosmological_constant(g; adiabatic),\n    K = nothing,\n    G = general_relativity(g; acceleration),\n    I = harrison_zeldovich(g; name = :I),\n    name = :RMΛ, kwargs...\n)\n\nCreate a simple model with pure non-interacting radiation, matter and cosmological constant.\n\n\n\n\n\n","category":"function"},{"location":"models/","page":"Cosmologies (full models)","title":"Cosmologies (full models)","text":"using SymBoltz, Unitful, UnitfulAstro, Plots\nM = RMΛ()\npars = Dict(M.r.Ω₀ => 5e-5, M.m.Ω₀ => 0.3, M.g.h => 1.0, M.r.T₀ => NaN) # TODO: don't pass h and T₀ to avoid infinite loop\nprob = CosmologyProblem(M, pars)\nks = [1e-3, 1e-2, 1e-1, 1e-0] / u\"Mpc\"\nsol = solve(prob, ks)\np1 = plot(sol, log10(M.g.a), [M.r.ρ, M.m.ρ, M.Λ.ρ, M.G.ρ] ./ M.G.ρ)\np2 = plot(sol, log10(M.g.a), M.g.Φ, ks)\nplot(p1, p2, layout = (2, 1), size = (600, 600))","category":"page"},{"location":"models/#Standard-ΛCDM","page":"Cosmologies (full models)","title":"Standard ΛCDM","text":"","category":"section"},{"location":"models/#SymBoltz.ΛCDM","page":"Cosmologies (full models)","title":"SymBoltz.ΛCDM","text":"ΛCDM(;\n    lmax = 6,\n    recombination = true,\n    reionization = true,\n    acceleration = false,\n    g = metric(),\n    G = general_relativity(g; acceleration),\n    γ = photons(g; lmax),\n    ν = massless_neutrinos(g; lmax),\n    h = massive_neutrinos(g; lmax),\n    c = cold_dark_matter(g; name = :c),\n    b = baryons(g; recombination, reionization, name = :b),\n    K = nothing,\n    Λ = cosmological_constant(g),\n    I = harrison_zeldovich(g; name = :I),\n    name = :ΛCDM,\n    kwargs...\n)\n\nCreate a ΛCDM model.\n\n\n\n\n\n","category":"function"},{"location":"models/","page":"Cosmologies (full models)","title":"Cosmologies (full models)","text":"using SymBoltz, Plots, Unitful, UnitfulAstro\nM = ΛCDM()\npars = parameters_Planck18(M)\nprob = CosmologyProblem(M, pars)\nks = [1e-3, 1e-2, 1e-1, 1e-0] / u\"Mpc\"\nsol = solve(prob, ks)\np1 = plot(sol, log10(M.g.a), [M.γ.ρ, M.ν.ρ, M.h.ρ, M.b.ρ, M.c.ρ, M.Λ.ρ, M.G.ρ] ./ M.G.ρ)\np2 = plot(sol, log10(M.g.a), M.g.Φ, ks)\nplot(p1, p2, layout = (2, 1), size = (600, 600))","category":"page"},{"location":"models/#wwₐCDM-(CPL-parametrization)","page":"Cosmologies (full models)","title":"w₀wₐCDM (CPL parametrization)","text":"","category":"section"},{"location":"models/#SymBoltz.w0waCDM","page":"Cosmologies (full models)","title":"SymBoltz.w0waCDM","text":"w0waCDM(; name = :w0waCDM, kwargs...)\n\nCreate a ΛCDM model, but with w₀wₐ-parametrized dark energy instead of the cosmological constant.\n\n\n\n\n\n","category":"function"},{"location":"models/","page":"Cosmologies (full models)","title":"Cosmologies (full models)","text":"using SymBoltz, Plots, Unitful, UnitfulAstro\nM = w0waCDM()\npars = merge(parameters_Planck18(M), Dict(\n    M.X.w0 => -0.9,\n    M.X.wa => 0.2,\n    M.X.cₛ² => 1.0\n))\nks = [1e-3, 1e-2, 1e-1, 1e-0] / u\"Mpc\"\nprob = CosmologyProblem(M, pars)\nsol = solve(prob, ks)\np1 = plot(sol, log10(M.g.a), M.X.w)\np2 = plot(sol, log10(M.g.a), M.X.δ, ks)\nplot(p1, p2, layout = (2, 1), size = (600, 600))","category":"page"},{"location":"models/#Brans-Dicke-ΛCDM","page":"Cosmologies (full models)","title":"Brans-Dicke ΛCDM","text":"","category":"section"},{"location":"models/#SymBoltz.BDΛCDM","page":"Cosmologies (full models)","title":"SymBoltz.BDΛCDM","text":"BDΛCDM(; name = :BDΛCDM, kwargs...)\n\nCreate a ΛCDM model, but with the Brans-Dicke theory of gravity instead of General Relativity.\n\n\n\n\n\n","category":"function"},{"location":"models/","page":"Cosmologies (full models)","title":"Cosmologies (full models)","text":"Solve background such that E = G = 1 today, and plot scalar field and Hubble function:","category":"page"},{"location":"models/","page":"Cosmologies (full models)","title":"Cosmologies (full models)","text":"using SymBoltz, Unitful, UnitfulAstro, Plots\nM = BDΛCDM()\nD = Differential(M.τ)\nks = [1e-3, 1e-2, 1e-1, 1e-0] / u\"Mpc\"\npars = merge(parameters_Planck18(M), Dict(M.G.ω => 100.0, D(M.G.ϕ) => 0.0)) # unspecified: M.Λ.Ω₀, M.G.ϕ\nprob = CosmologyProblem(M, pars, Dict(M.G.ϕ => 0.95, M.Λ.Ω₀ => 0.5), [M.g.ℰ ~ 1, M.G.G ~ 1])\nsol = solve(prob, ks; verbose = true)\np1 = plot(sol, log10(M.g.a), [M.g.ℰ, M.G.G], ylims = (0.8, 1.2))\np2 = plot(sol, log10(M.g.a), M.G.δϕ, ks)\nplot(p1, p2, layout = (2, 1), size = (600, 600))","category":"page"},{"location":"models/#Brans-Dicke-RMΛ","page":"Cosmologies (full models)","title":"Brans-Dicke RMΛ","text":"","category":"section"},{"location":"models/","page":"Cosmologies (full models)","title":"Cosmologies (full models)","text":"using SymBoltz, Unitful, UnitfulAstro, Plots\nM = SymBoltz.BDRMΛ()\nD = Differential(M.τ)\npars = Dict(M.r.Ω₀ => 5e-5, M.m.Ω₀ => 0.3, M.g.h => 1.0, M.r.T₀ => 0.0, M.G.ω => 10.0, D(M.G.ϕ) => 0.0) # unspecified: M.Λ.Ω₀, M.G.ϕ\nprob = CosmologyProblem(M, pars, Dict(M.G.ϕ => 0.8, M.Λ.Ω₀ => 0.8), [M.g.ℰ ~ 1, M.G.G ~ 1])\nk = 1e-0 / u\"Mpc\"\nsol = solve(prob, k; verbose = true)\np1 = plot(sol, log10(M.g.a), M.G.G)\np2 = plot(sol, log10(M.g.a), M.G.δϕ, k)\nplot(p1, p2, layout = (2, 1))","category":"page"},{"location":"models/#Quintessence-CDM","page":"Cosmologies (full models)","title":"Quintessence-CDM","text":"","category":"section"},{"location":"models/#SymBoltz.QCDM","page":"Cosmologies (full models)","title":"SymBoltz.QCDM","text":"QCDM(v; name = :QCDM, kwargs...)\n\nCreate a ΛCDM model, but with the quintessence scalar field in the potential v as dark energy instead of the cosmological constant.\n\n\n\n\n\n","category":"function"},{"location":"models/","page":"Cosmologies (full models)","title":"Cosmologies (full models)","text":"using SymBoltz, Plots\n@parameters V0 N\nV = ϕ -> V0 * ϕ^N\nM = QCDM(V, I = nothing)\nD = Differential(M.τ)\npars = merge(parameters_Planck18(M), Dict(M.Q.ϕ => 1, D(M.Q.ϕ) => 1.0, M.Q.V0 => 1e-2, M.Q.N => 2))\nprob = CosmologyProblem(M, pars)\nsol = solve(prob) # TODO: shoot so M.g.ℰ ~ 1 today\nplot(sol, M.Q.ϕ, M.Q.V, line_z = log10(M.g.a)) # plot V(ϕ(τ))","category":"page"},{"location":"observables/#Observable-quantities","page":"Observable quantities","title":"Observable quantities","text":"","category":"section"},{"location":"observables/","page":"Observable quantities","title":"Observable quantities","text":"This page shows observable quantities that can be derived from solutions of the Einstein-Boltzmann system, such as power spectra and distances.","category":"page"},{"location":"observables/#Primordial-power-spectra","page":"Observable quantities","title":"Primordial power spectra","text":"","category":"section"},{"location":"observables/#SymBoltz.spectrum_primordial","page":"Observable quantities","title":"SymBoltz.spectrum_primordial","text":"spectrum_primordial(k, h, As, ns=1.0; kp = k_dimensionless(0.05 / u\"Mpc\", h))\n\nCompute the primordial power spectrum\n\nP₀(k) = 2π² Aₛ (kkₚ)^nₛ-1  k³\n\nwith spectral amplitude As, spectral index ns and pivot scale wavenumber kp at the wavenumber(s) k.\n\n\n\n\n\n","category":"function"},{"location":"observables/#Example","page":"Observable quantities","title":"Example","text":"","category":"section"},{"location":"observables/","page":"Observable quantities","title":"Observable quantities","text":"using SymBoltz, Unitful, UnitfulAstro, Plots\nM = SymBoltz.ΛCDM()\npars = Dict(M.g.h => 0.7, M.I.As => 2e-9, M.I.ns => 0.95)\nks = 10 .^ range(-5, +1, length=100) / u\"Mpc\"\nPs = spectrum_primordial(ks, M, pars)\nplot(log10.(ks*u\"Mpc\"), log10.(Ps/u\"Mpc^3\"); xlabel = \"log10(k/Mpc⁻¹)\", ylabel = \"log10(P/Mpc³)\")","category":"page"},{"location":"observables/#Matter-power-spectra","page":"Observable quantities","title":"Matter power spectra","text":"","category":"section"},{"location":"observables/#SymBoltz.spectrum_matter","page":"Observable quantities","title":"SymBoltz.spectrum_matter","text":"spectrum_matter(sol::CosmologySolution, k, τ = sol[τ][end]; species = [:c, :b, :h])\n\nCompute the power spectrum\n\nP(kτ) = P₀(k) Δ(kτ)²\n\nof the total gauge-invariant overdensity\n\nΔ = δ + (3ℰk²) θ = (ₛδρ)(ₛρₛ) + (3ℰk²) (ₛ(ρₛ+Pₛ)θₛ)  (ₛ(ρₛ+Pₛ))\n\nfor the given species at wavenumber(s) k and conformal time(s) tau (final, if omitted) from the solution sol. By default, the species are cold dark matter, baryons and massive neutrinos, which are matter-like at late times in the ΛCDM model.\n\n\n\n\n\nspectrum_matter(prob::CosmologyProblem, k, τ = nothing; species = [:c, :b, :h], kwargs...)\n\nSolve the problem prob with exact wavenumber(s) k, and then compute the power spectrum with the solution sol.\n\n\n\n\n\n","category":"function"},{"location":"observables/#SymBoltz.spectrum_matter_nonlinear","page":"Observable quantities","title":"SymBoltz.spectrum_matter_nonlinear","text":"spectrum_matter_nonlinear(sol::CosmologySolution, k)\n\nCompute the nonlinear matter power spectrum from the cosmology solution sol at wavenumber(s) k using halofit implemented in MatterPower.jl.\n\n\n\n\n\n","category":"function"},{"location":"observables/#Example-2","page":"Observable quantities","title":"Example","text":"","category":"section"},{"location":"observables/","page":"Observable quantities","title":"Observable quantities","text":"using SymBoltz, Unitful, UnitfulAstro, Plots\nM = SymBoltz.ΛCDM()\npars = SymBoltz.parameters_Planck18(M)\nprob = CosmologyProblem(M, pars)\nks = 10 .^ range(-5, +2, length=200) / u\"Mpc\"\nsol = solve(prob, ks)\n\n# Linear power spectrum\nPs = spectrum_matter(sol, ks)\nplot(log10.(ks*u\"Mpc\"), log10.(Ps/u\"Mpc^3\"); xlabel = \"log10(k/Mpc⁻¹)\", ylabel = \"log10(P/Mpc³)\", label = \"linear (SymBoltz)\")\n\n# Nonlinear power spectrum (from halofit)\nPs = spectrum_matter_nonlinear(sol, ks)\nplot!(log10.(ks*u\"Mpc\"), log10.(Ps/u\"Mpc^3\"); label = \"non-linear (halofit)\", legend_position = :bottomleft)","category":"page"},{"location":"observables/#CMB-power-spectra","page":"Observable quantities","title":"CMB power spectra","text":"","category":"section"},{"location":"observables/#SymBoltz.spectrum_cmb","page":"Observable quantities","title":"SymBoltz.spectrum_cmb","text":"spectrum_cmb(ΘlAs::AbstractMatrix, ΘlBs::AbstractMatrix, P0s::AbstractVector, ls::AbstractVector, ks::AbstractVector; integrator = TrapezoidalRule(), normalization = :Cl)\n\nCompute the angular power spectrum\n\nCₗᴬᴮ = (2π) mathrmdk  k² P₀(k) Θₗᴬ(kτ₀) Θₗᴮ(kτ₀)\n\nfor the given ls. If normaliation == :Dl, compute Dₗ = Cₗ l (l+1)  2π instead.\n\n\n\n\n\nspectrum_cmb(modes::AbstractVector, prob::CosmologyProblem, ls::AbstractVector; normalization = :Cl, unit = nothing, Δkτ0 = 2π/2, Δkτ0_S = 8.0, kτ0min = 0.1*ls[begin], kτ0max = 3*ls[end], u = (τ->tanh(τ)), u⁻¹ = (u->atanh(u)), Nlos = 768, integrator = TrapezoidalRule(), bgopts = (alg = Rodas4P(), reltol = 1e-9, abstol = 1e-9), ptopts = (alg = KenCarp4(), reltol = 1e-8, abstol = 1e-8), thread = true, kwargs...)\n\nCompute the CMB power spectra modes (:TT, :EE, :TE or an array thereof) C_l^AB's at angular wavenumbers ls from the cosmological solution sol. If unit is nothing the spectra are of dimensionless temperature fluctuations relative to the present photon temperature; while if unit is a temperature unit the spectra are of dimensionful temperature fluctuations.\n\n\n\n\n\nspectrum_cmb(modes::AbstractVector, prob::CosmologyProblem, ls::AbstractVector, ls_interpolate_from::AbstractVector; kwargs...)\n\nSame, but compute the spectrum properly only for ls_interpolate_from and then interpolate the results to all ls.\n\n\n\n\n\n","category":"function"},{"location":"observables/#Example-3","page":"Observable quantities","title":"Example","text":"","category":"section"},{"location":"observables/","page":"Observable quantities","title":"Observable quantities","text":"# TODO: more generic, source functions, ... # hide\nusing SymBoltz, Unitful, UnitfulAstro, Plots\nM = SymBoltz.ΛCDM()\npars = SymBoltz.parameters_Planck18(M)\nprob = CosmologyProblem(M, pars)\nls = 10:5:1500\n\nDls = spectrum_cmb([:TT, :EE, :TE], prob, ls; normalization = :Dl, unit = u\"μK\")\npTT = plot(ls, Dls[:, 1]; ylabel = \"Dₗᵀᵀ\")\npEE = plot(ls, Dls[:, 2]; ylabel = \"Dₗᴱᴱ\")\npTE = plot(ls, Dls[:, 3]; ylabel = \"Dₗᵀᴱ\", xlabel = \"l\")\nplot(pTT, pEE, pTE, layout = (3, 1), size = (600, 700), legend = nothing)","category":"page"},{"location":"observables/#Two-point-correlation-function","page":"Observable quantities","title":"Two-point correlation function","text":"","category":"section"},{"location":"observables/#SymBoltz.correlation_function","page":"Observable quantities","title":"SymBoltz.correlation_function","text":"correlation_function(sol::CosmologySolution; N = 2048, spline = true)\n\nCompute the two-point correlation function in real space by Fourier transforming the matter power spectrum of sol with N points the FFTLog algorithm implemented in TwoFAST. Returns N radii and correlation function values (e.g. r, ξ).\n\n\n\n\n\n","category":"function"},{"location":"observables/#Example-4","page":"Observable quantities","title":"Example","text":"","category":"section"},{"location":"observables/","page":"Observable quantities","title":"Observable quantities","text":"using SymBoltz, Unitful, UnitfulAstro, Plots\nM = SymBoltz.ΛCDM()\npars = SymBoltz.parameters_Planck18(M)\nprob = CosmologyProblem(M, pars)\nks = 10 .^ range(-5, +3, length=300) / u\"Mpc\"\nsol = solve(prob, ks)\nrs, ξs = correlation_function(sol)\nrs = rs / (SymBoltz.k0*sol.bg.ps[:h]) * u\"Mpc\" # TODO: auto units\nplot(rs, @. ξs * rs^2; xlims = (0, 200), xlabel = \"r\", ylabel = \"r² ξ\")","category":"page"},{"location":"observables/#Matter-density-fluctuations","page":"Observable quantities","title":"Matter density fluctuations","text":"","category":"section"},{"location":"observables/#SymBoltz.variance_matter","page":"Observable quantities","title":"SymBoltz.variance_matter","text":"variance_matter(sol::CosmologySolution, R)\n\nCompute the variance δ² of the linear matter density field with a top-hat filter with radius R. Wraps the implementation in MatterPower.jl.\n\n\n\n\n\n","category":"function"},{"location":"observables/#SymBoltz.stddev_matter","page":"Observable quantities","title":"SymBoltz.stddev_matter","text":"stddev_matter(sol::CosmologySolution, R)\n\nCompute the standard deviation (δ²) of the linear matter density field with a top-hat filter with radius R.\n\n\n\n\n\n","category":"function"},{"location":"observables/","page":"Observable quantities","title":"Observable quantities","text":"using SymBoltz, Unitful, UnitfulAstro, Plots\nM = SymBoltz.ΛCDM()\npars = SymBoltz.parameters_Planck18(M)\nprob = CosmologyProblem(M, pars)\nks = 10 .^ range(-5, +3, length=300) / u\"Mpc\"\nsol = solve(prob, ks)\n\nh = sol[M.g.h]\nRs = 10 .^ range(0, 2, length=100) * u\"Mpc\"\nσs = stddev_matter.(sol, Rs)\nplot(log10.(Rs/(u\"Mpc\"/h)), log10.(σs); xlabel = \"lg(R / (Mpc/h))\", ylabel = \"lg(σ)\", label = nothing)\n\nR8 = 8 * u\"Mpc\"/h\nσ8 = stddev_matter(sol, R8)\nscatter!((log10(R8/(u\"Mpc\"/h)), log10(σ8)), series_annotation = text(\"  σ₈ = $(round(σ8; digits=3))\", :left), label = nothing)","category":"page"},{"location":"observables/#Luminosity-distance","page":"Observable quantities","title":"Luminosity distance","text":"","category":"section"},{"location":"observables/#SymBoltz.distance_luminosity","page":"Observable quantities","title":"SymBoltz.distance_luminosity","text":"distance_luminosity(sol::CosmologySolution, ivs = sol.bg.t, τ0 = sol[sol.prob.M.τ0])\n\nCompute luminosity distances\n\nd_L = fracra = chi  mathrmsinc (sqrtK (τ₀-τ))\n\nat the independent variable values ivs relative to the (present) time τ0.\n\n\n\n\n\n","category":"function"},{"location":"observables/","page":"Observable quantities","title":"Observable quantities","text":"using SymBoltz, Plots\nM = SymBoltz.RMΛ(K = SymBoltz.curvature(SymBoltz.metric()))\npars = Dict(\n    M.r.Ω₀ => 5e-5,\n    M.m.Ω₀ => 0.3,\n    M.K.Ω₀ => 0.1,\n    M.r.T₀ => NaN,\n    M.g.h => 0.7\n)\nprob = CosmologyProblem(M, pars)\nsol = solve(prob)\n\nzs = 0.0:1.0:10.0\nτs = SymBoltz.timeseries(sol, M.g.z, zs) # times at given redshifts\ndLs = SymBoltz.distance_luminosity(sol, τs) / SymBoltz.Gpc\n@assert dLs[begin] == 0.0 || zs[begin] != 0.0 # ensure bug does not reappear # hide\nplot(zs, dLs; marker=:dot, xlabel=\"z\", ylabel=\"dL / Gpc\", label=nothing)","category":"page"},{"location":"observables/#Sound-horizon-(BAO-scale)","page":"Observable quantities","title":"Sound horizon (BAO scale)","text":"","category":"section"},{"location":"observables/#SymBoltz.sound_horizon","page":"Observable quantities","title":"SymBoltz.sound_horizon","text":"sound_horizon(sol::CosmologySolution)\n\nCumulatively integrate the sound horizon\n\n    rₛ(τ) = _0^τ dτ cₛ = _0^τ fracdτ(3(1+3ρ_b4ρ_γ))\n\nto the time steps of the solution sol.\n\n\n\n\n\n","category":"function"},{"location":"observables/","page":"Observable quantities","title":"Observable quantities","text":"using SymBoltz, Plots\nM = SymBoltz.ΛCDM()\npars = SymBoltz.parameters_Planck18(M)\nprob = CosmologyProblem(M, pars)\nsol = solve(prob)\nτs = sol[M.τ]\nrs = sound_horizon(sol)\nplot(τs, rs; xlabel = \"τ / H₀⁻¹\", ylabel = \"rₛ / (c/H₀)\")","category":"page"},{"location":"observables/#Line-of-sight-integration","page":"Observable quantities","title":"Line-of-sight integration","text":"","category":"section"},{"location":"observables/#SymBoltz.los_integrate","page":"Observable quantities","title":"SymBoltz.los_integrate","text":"los_integrate(Ss::AbstractMatrix{T}, ls::AbstractVector, τs::AbstractVector, ks::AbstractVector, Rl::Function; integrator = TrapezoidalRule(), verbose = false) where {T <: Real}\n\nFor the given ls and ks, compute the line-of-sight-integrals\n\nIₗ(k) = dτ S(kτ) Rₗ(k(τ₀-τ))\n\nover the source function values Ss against the radial functions Rl (e.g. the spherical Bessel functions jₗ(x)). The element Ss[i,j] holds the source function value S(kᵢ τⱼ).\n\n\n\n\n\n","category":"function"},{"location":"plot/#Plotting-and-visualization","page":"Plotting and visualization","title":"Plotting and visualization","text":"","category":"section"},{"location":"plot/","page":"Plotting and visualization","title":"Plotting and visualization","text":"note: Note\nThis page is work-in-progress.","category":"page"},{"location":"plot/","page":"Plotting and visualization","title":"Plotting and visualization","text":"First, set up a cosmological problem to solve:","category":"page"},{"location":"plot/","page":"Plotting and visualization","title":"Plotting and visualization","text":"using SymBoltz, Unitful, UnitfulAstro\nM = SymBoltz.ΛCDM()\npars = SymBoltz.parameters_Planck18(M)\nprob = CosmologyProblem(M, pars)","category":"page"},{"location":"plot/#Static-plot-recipes","page":"Plotting and visualization","title":"Static plot recipes","text":"","category":"section"},{"location":"plot/","page":"Plotting and visualization","title":"Plotting and visualization","text":"Use SymBoltz' included plot recipes to plot the evolution of background and perturbation quantities over time:","category":"page"},{"location":"plot/","page":"Plotting and visualization","title":"Plotting and visualization","text":"import Plots\nks = [1e-3, 1e-2, 1e-1, 1e0] / u\"Mpc\"\nsol = solve(prob, ks)\np1 = Plots.plot(sol, M.χ, M.g.a)\np2 = Plots.plot(sol, log10(M.g.a), [M.g.Φ, M.g.Ψ], ks)\nPlots.plot(p1, p2; layout = (2, 1), size = (600, 600))","category":"page"},{"location":"plot/","page":"Plotting and visualization","title":"Plotting and visualization","text":"Plot the evolution of Φ(kτ) over conformal time τ:","category":"page"},{"location":"plot/","page":"Plotting and visualization","title":"Plotting and visualization","text":"ks = 10 .^ range(-3, 0, length=100) / u\"Mpc\"\nsol = solve(prob, ks)\nτs = [0.0, 1e-5, 1e-4, 1e-3, 1e-2, 1e-1, 1e0]\npal = Plots.palette([:black, :orange], length(τs))\ncolor = permutedims([pal[i] for i in eachindex(τs)])\nlabels = permutedims(map(τ -> \"τ/H₀⁻¹ = $τ\", τs))\nPlots.plot(log10.(ks*u\"Mpc\"), permutedims(sol(M.g.Φ, τs, ks)); xlabel = \"k/Mpc⁻¹\", ylabel = \"Φ(τ,k)\", color, labels)","category":"page"},{"location":"plot/","page":"Plotting and visualization","title":"Plotting and visualization","text":"Visualize the CMB source function S₀(kτ) in a 3D plot:","category":"page"},{"location":"plot/","page":"Plotting and visualization","title":"Plotting and visualization","text":"using CairoMakie\nτs = range(0.05, 0.08; length=50)\nks = range(0.0, 0.3, length=100) / u\"Mpc\"\nsol = solve(prob, ks)\n\nxs = τs\nys = ks*u\"Mpc\"\nzs = sol(M.ST0, τs, ks)\n\nfig = Figure()\nax = Axis3(fig[1,1], azimuth = π/4, xlabel = \"k/Mpc⁻¹\", ylabel = \"τ/H₀⁻¹\", zlabel = \"S₀(τ,k)\")\ncmax = min(-minimum(filter(!isnan, zs)), maximum(filter(!isnan, zs))) # saturate both ends of color scale\nsurface!(ax, xs, ys, zs; alpha = 0.9, colormap = :seismic, colorrange = (-cmax, +cmax))\n\nfig","category":"page"},{"location":"plot/#Interactive-visualization","page":"Plotting and visualization","title":"Interactive visualization","text":"","category":"section"},{"location":"plot/","page":"Plotting and visualization","title":"Plotting and visualization","text":"The excellent Makie plotting library can be used to interactively visualize results:","category":"page"},{"location":"plot/","page":"Plotting and visualization","title":"Plotting and visualization","text":"using GLMakie","category":"page"},{"location":"plot/","page":"Plotting and visualization","title":"Plotting and visualization","text":"We can now build a simple interactive interface that updates a plotted function when the user drags parameter value sliders:","category":"page"},{"location":"plot/","page":"Plotting and visualization","title":"Plotting and visualization","text":"using CairoMakie # for showing static doc image # hide\n\n# TODO: move into SymBoltz plotting recipes once MakieCore supports @lift etc.\n# TODO: take in (xyfunc) as a function that can plot anything # hide\n# TODO: handle wavenumber perturbations etc. # hide\n# TODO: plot multiple y vars # hide\nfunction plot_interactive(prob::CosmologyProblem, xyfunc::Function, obspars...; xlabel = \"\", ylabel = \"\", kwargs...)\n    fig = Figure(size = (800, 800), fontsize = 18)\n    ax = Axis(fig[1, 1]; xlabel, ylabel)\n    sg = SliderGrid(fig[2, 1], ((label = SymBoltz.displayname(par), range = range, startvalue = prob.bg.ps[par]) for (par, range) in obspars)...)\n\n    obs = Observable([pars[par] for (par, _) in obspars]) # observable array for all parameters\n    obss = [Observable(pars[par]) for (par, _) in obspars] # array of observables for each parameter\n\n    for i in 1:length(obspars)\n        # update full parameter array when individual parameters change\n        on(obss[i]) do val\n            vals = obs[]\n            vals[i] = val\n            obs[] = vals\n        end\n        connect!(obss[i], sg.sliders[i].value)\n    end\n\n    lines!(ax, @lift(xyfunc($obs)); kwargs...)\n\n    return fig\nend\nfunction plot_interactive(prob::CosmologyProblem, xvar::SymBoltz.Num, yvar::SymBoltz.Num, obspars...; N = 2000, kwargs...)\n    # select points according to cumulative distribution of ODE solver's adaptive time steps\n    function τs(sol)\n        τ = sol.bg.t\n        τcum(n) = τ[Int(floor(n))] + (τ[min(Int(floor(n))+1,length(τ))] - τ[Int(floor(n))]) * (n - floor(n)) # <3\n        return τcum.(range(1, length(τ), length = N))\n    end\n    probgen = parameter_updater(prob, [par for (par, _) in obspars])\n    function xyfunc(θ)\n        prob = probgen(θ)\n        sol = solve(prob)\n        τ = τs(sol)\n        xs = sol(xvar, τ)\n        ys = sol(yvar, τ)\n        return collect(zip(xs, ys)) # [(x1, y1), (x2, y2), ...]\n    end\n    return plot_interactive(prob, xyfunc, obspars...; xlabel = SymBoltz.displayname(xvar), ylabel = SymBoltz.displayname(yvar), kwargs...)\nend\n\nobspars = [\n    M.g.h => 0.60:0.01:0.70,\n    M.c.Ω₀ => 0.20:0.01:0.30,\n    M.b.Ω₀ => 0.02:0.01:0.10,\n    M.γ.T₀ => 2.50:0.01:3.00,\n    M.h.m_eV => 0.01:0.01:0.15,\n    M.b.rec.Yp => 0.20:0.01:0.30,\n    M.ν.Neff => 2.90:0.01:3.10\n]\nfig = plot_interactive(prob, log10(M.g.a), M.b.rec.Xe, obspars...)","category":"page"},{"location":"plot/","page":"Plotting and visualization","title":"Plotting and visualization","text":"info: Info\nThis plot is static due to limitations in the documentation building system. It is interactive when you execute the code locally.","category":"page"},{"location":"plot/","page":"Plotting and visualization","title":"Plotting and visualization","text":"We can make a similar plot for the matter power spectrum P(k θ) as a function of cosmological parameters:","category":"page"},{"location":"plot/","page":"Plotting and visualization","title":"Plotting and visualization","text":"using DataInterpolations # for smoothing\nobspars = [\n    obspars; # extend vector from above\n    M.I.ln_As1e10 => 2.0:0.1:4.0\n    M.I.ns => 0.90:0.01:1.10\n]\nprobgen = parameter_updater(prob, [par for (par, _) in obspars])\nfunction xyfunc(θ)\n    prob = probgen(θ)\n    lgks = unique([-4:0.5:-3; -3:0.2:-2; -2:0.05:0]) # as few points as possible\n    ks = 10 .^ lgks / u\"Mpc\"\n    Ps = spectrum_matter(prob, ks; ptopts = (alg = SymBoltz.TRBDF2(), reltol = 1e-4, abstol = 1e-4))\n    lgPs = log10.(Ps/u\"Mpc^3\")\n\n    # smoothen with spline and sample more densely\n    lgPspline = CubicSpline(lgPs, lgks)\n    lgks = range(lgks[begin], lgks[end]; step = 0.01)\n    lgPs = lgPspline(lgks)\n\n    return collect(zip(lgks, lgPs)) # [(x1, y1), (x2, y2), ...]\nend\nfig = plot_interactive(prob, xyfunc, obspars...; xlabel = \"lg(k / Mpc⁻¹)\", ylabel = \"lg(P / Mpc³)\")","category":"page"},{"location":"plot/","page":"Plotting and visualization","title":"Plotting and visualization","text":"info: Info\nThis plot is static due to limitations in the documentation building system. It is interactive when you execute the code locally.","category":"page"},{"location":"automatic_differentiation/#Using-automatic-differentiation","page":"Using automatic differentiation","title":"Using automatic differentiation","text":"","category":"section"},{"location":"automatic_differentiation/","page":"Using automatic differentiation","title":"Using automatic differentiation","text":"This tutorial shows how to compute the power spectrum P(k theta) and its (logarithmic) derivatives","category":"page"},{"location":"automatic_differentiation/","page":"Using automatic differentiation","title":"Using automatic differentiation","text":"fracpartial lg Ppartial lg theta_i","category":"page"},{"location":"automatic_differentiation/","page":"Using automatic differentiation","title":"Using automatic differentiation","text":"using automatic differentiation with ForwardDiff.jl. This technique can also differentiate any other quantity.","category":"page"},{"location":"automatic_differentiation/#1.-Wrap-the-evaluation","page":"Using automatic differentiation","title":"1. Wrap the evaluation","text":"","category":"section"},{"location":"automatic_differentiation/","page":"Using automatic differentiation","title":"Using automatic differentiation","text":"First, we must decide which parameters theta the power spectrum P(k theta) should be considered a function of. To do so, let us write a small wrapper function that calculates the power spectrum as a function of the parameters (T_gamma 0 Omega_c0 Omega_b0 N_textrmeff h Y_p), following the Getting started tutorial:","category":"page"},{"location":"automatic_differentiation/","page":"Using automatic differentiation","title":"Using automatic differentiation","text":"using SymBoltz\nM = ΛCDM(K = nothing)\npars = [M.γ.T₀, M.c.Ω₀, M.b.Ω₀, M.ν.Neff, M.g.h, M.b.rec.Yp, M.h.m_eV, M.I.ln_As1e10, M.I.ns]\nprob0 = CosmologyProblem(M, Dict(pars .=> NaN))\n\nprobgen = parameter_updater(prob0, pars)\nP(k, θ) = spectrum_matter(probgen(θ), k; verbose = true, ptopts = (reltol = 1e-3,))","category":"page"},{"location":"automatic_differentiation/","page":"Using automatic differentiation","title":"Using automatic differentiation","text":"It is now easy to evaluate the power spectrum:","category":"page"},{"location":"automatic_differentiation/","page":"Using automatic differentiation","title":"Using automatic differentiation","text":"using Unitful, UnitfulAstro\nθ = [2.7, 0.27, 0.05, 3.0, 0.7, 0.25, 0.06, 3.0, 0.95]\nks = 10 .^ range(-3, 0, length=100) / u\"Mpc\"\nPs = P(ks, θ)","category":"page"},{"location":"automatic_differentiation/","page":"Using automatic differentiation","title":"Using automatic differentiation","text":"This can be plotted with","category":"page"},{"location":"automatic_differentiation/","page":"Using automatic differentiation","title":"Using automatic differentiation","text":"using Plots\nplot(log10.(ks/u\"1/Mpc\"), log10.(Ps/u\"Mpc^3\"); xlabel = \"lg(k/Mpc⁻¹)\", ylabel = \"lg(P/Mpc³)\", label = nothing)","category":"page"},{"location":"automatic_differentiation/#2.-Calculate-the-derivatives","page":"Using automatic differentiation","title":"2. Calculate the derivatives","text":"","category":"section"},{"location":"automatic_differentiation/","page":"Using automatic differentiation","title":"Using automatic differentiation","text":"To get partial lg P  partial lg theta, we can simply pass the wrapper function P(k, θ) through ForwardDiff.jacobian:","category":"page"},{"location":"automatic_differentiation/","page":"Using automatic differentiation","title":"Using automatic differentiation","text":"using ForwardDiff\nlgP(lgθ) = log10.(P(ks, 10 .^ lgθ) / u\"Mpc^3\") # in log-space\ndlgP_dlgθs = ForwardDiff.jacobian(lgP, log10.(θ))","category":"page"},{"location":"automatic_differentiation/","page":"Using automatic differentiation","title":"Using automatic differentiation","text":"The matrix element dlgP_dlgθs[i, j] now contains partial lg P(k_i)  partial lg theta_j. We can plot them all at once:","category":"page"},{"location":"automatic_differentiation/","page":"Using automatic differentiation","title":"Using automatic differentiation","text":"plot(\n    log10.(ks/u\"1/Mpc\"), dlgP_dlgθs;\n    xlabel = \"lg(k/Mpc⁻¹)\", ylabel = \"∂ lg(P) / ∂ lg(θᵢ)\",\n    labels = \"θᵢ=\" .* [\"Tγ0\" \"Ωc0\" \"Ωb0\" \"Neff\" \"h\" \"Yp\" \"mh\" \"ln(10¹⁰As)\" \"ns\"]\n)","category":"page"},{"location":"automatic_differentiation/#Get-values-and-derivatives-together","page":"Using automatic differentiation","title":"Get values and derivatives together","text":"","category":"section"},{"location":"automatic_differentiation/","page":"Using automatic differentiation","title":"Using automatic differentiation","text":"The above example showed how to calculate the power spectrum values and their derivatives through two separate calls. If you need both, it is faster to calculate them simultaneously with the package DiffResults.jl:","category":"page"},{"location":"automatic_differentiation/","page":"Using automatic differentiation","title":"Using automatic differentiation","text":"using DiffResults\n\n# Following DiffResults documentation:\nPres = DiffResults.JacobianResult(ks/u\"1/Mpc\", θ) # allocate buffer for values+derivatives for a function with θ-sized input and ks-sized output\nPres = ForwardDiff.jacobian!(Pres, lgP, log10.(θ)) # evaluate values+derivatives of lgP(log10.(θ)) and store the results in Pres\nlgPs = DiffResults.value(Pres) # extract values\ndlgP_dlgθs = DiffResults.jacobian(Pres) # extract derivatives\n\np1 = plot(\n   log10.(ks/u\"1/Mpc\"), lgPs;\n   ylabel = \"lg(P/Mpc³)\", label = nothing\n)\np2 = plot(\n   log10.(ks/u\"1/Mpc\"), dlgP_dlgθs;\n   xlabel = \"lg(k/Mpc⁻¹)\", ylabel = \"∂ lg(P) / ∂ lg(θᵢ)\",\n   labels = \"θᵢ=\" .* [\"Tγ0\" \"Ωc0\" \"Ωb0\" \"Neff\" \"h\" \"Yp\" \"mh\" \"ln(10¹⁰As)\" \"ns\"]\n)\nplot(p1, p2, layout=(2, 1), size = (600, 600))","category":"page"},{"location":"automatic_differentiation/#General-approach","page":"Using automatic differentiation","title":"General approach","text":"","category":"section"},{"location":"automatic_differentiation/","page":"Using automatic differentiation","title":"Using automatic differentiation","text":"The technique shown here can be used to calculate the derivative of any SymBoltz.jl output quantity:","category":"page"},{"location":"automatic_differentiation/","page":"Using automatic differentiation","title":"Using automatic differentiation","text":"Write a wrapper function output(input) that calculates the desired output quantities from the desired input quantities.\nUse ForwardDiff.derivative(output, input) (scalar-to-scalar), ForwardDiff.gradient(output, input) (vector-to-scalar) or ForwardDiff.jacobian(output, input) (vector-to-vector) to evaluate the derivative of output at the values input. Or use the similar functions in DiffResults to calculate the value and derivatives simultaneously.","category":"page"},{"location":"forecasting/#Fisher-forecasting","page":"Fisher forecasting","title":"Fisher forecasting","text":"","category":"section"},{"location":"forecasting/","page":"Fisher forecasting","title":"Fisher forecasting","text":"Fisher forecasting is an important tool for estimating what constraints on parameters that observations with some given uncertainties can place. This example shows how SymBoltz can be used to perform a Fisher forecast on a CMB (TT) survey limited only by cosmic variance.","category":"page"},{"location":"forecasting/","page":"Fisher forecasting","title":"Fisher forecasting","text":"First, create a base ΛCDM cosmological model and problem:","category":"page"},{"location":"forecasting/","page":"Fisher forecasting","title":"Fisher forecasting","text":"# inspiration: e.g. https://github.com/xzackli/fishchips-public/blob/master/notebooks/Introduction%20to%20Fisher%20Forecasting.ipynb # hide\n# TODO: start by getting equal ad/fd results with these, then include more parameters # hide\nusing SymBoltz, Plots\nM = ΛCDM(K = nothing) # flat\npars = Dict(\n    M.g.h => 0.70,\n    M.c.Ω₀ => 0.27,\n    M.b.Ω₀ => 0.05,\n    M.γ.T₀ => 2.7,\n    M.ν.Neff => 3.0,\n    M.b.rec.Yp => 0.25,\n    M.h.m_eV => 0.06,\n    M.I.ln_As1e10 => 3.0,\n    M.I.ns => 0.96\n)\n# TODO: more parameters, try one-by-one: Neff is a bit iffy # hide\npars_varying = [M.g.h, M.c.Ω₀, M.b.Ω₀, M.b.rec.Yp, M.I.ln_As1e10, M.I.ns] # parameters to be varied; others are fixed\nprob0 = CosmologyProblem(M, merge(pars, Dict(pars_varying .=> NaN))) # set varying to NaN","category":"page"},{"location":"forecasting/","page":"Fisher forecasting","title":"Fisher forecasting","text":"Next, create a function for computing Cₗ of the CMB TT power spectrum. Since Cₗ is an expensive but smooth function of l, we make one function for it exactly on a coarse grid of l and another for interpolating it to a finer grid:","category":"page"},{"location":"forecasting/","page":"Fisher forecasting","title":"Fisher forecasting","text":"# TODO: ω0 better than Ω0? # hide\nprobgen = parameter_updater(prob0, pars_varying)\nls, ls′ = 40:1:1000, 40:20:1000\nfunction Cl(θ; bgopts = (alg = SymBoltz.Rodas4P(), reltol = 1e-9, abstol = 1e-9), ptopts = (alg = SymBoltz.KenCarp4(), reltol = 1e-8, abstol = 1e-8))\n    return spectrum_cmb(:TT, probgen(θ), ls, ls′; bgopts, ptopts)\nend","category":"page"},{"location":"forecasting/","page":"Fisher forecasting","title":"Fisher forecasting","text":"We can now compute Cₗ and the cosmic variance uncertainties","category":"page"},{"location":"forecasting/","page":"Fisher forecasting","title":"Fisher forecasting","text":"σₗ = sqrtfrac22l+1 Cₗ","category":"page"},{"location":"forecasting/","page":"Fisher forecasting","title":"Fisher forecasting","text":"and plot them with error bars:","category":"page"},{"location":"forecasting/","page":"Fisher forecasting","title":"Fisher forecasting","text":"θ0 = [pars[par] for par in pars_varying]\nCls = Cl(θ0)\nσs = @. √(2/(2ls+1)) * Cls # cosmic variance\nplot(ls, Cls.*ls.*(ls.+1)/2π; ribbon = σs.*ls.*(ls.+1)/2π, xlabel = \"l\", ylabel = \"l(l+1)Cₗ/2π\", label = \"Dₗ ± ΔDₗ\")","category":"page"},{"location":"forecasting/","page":"Fisher forecasting","title":"Fisher forecasting","text":"The likelihood (logarithm) function (given model parameters θ and measured barCₗ) is","category":"page"},{"location":"forecasting/","page":"Fisher forecasting","title":"Fisher forecasting","text":"log L(θ) = -frac12 sum_i left( fracCₗ(θ)-Cₗσᵢ right)²","category":"page"},{"location":"forecasting/","page":"Fisher forecasting","title":"Fisher forecasting","text":"To calculate parameter covariances, we first need the Fisher information matrix:","category":"page"},{"location":"forecasting/","page":"Fisher forecasting","title":"Fisher forecasting","text":"Fᵢⱼ = -frac12 ₗ left frac² log Lθᵢ θⱼ right = ₗ fracCₗθᵢ frac1σₗ² fracCₗθⱼ","category":"page"},{"location":"forecasting/","page":"Fisher forecasting","title":"Fisher forecasting","text":"Notice that the Fisher matrix is independent of the measured Cₗ, and depends only on the uncertainties and the derivatives of the Cₗ with respect to the cosmological parameters. We can compute the derivatives using automatic differentiation, and compare them to those found with finite differences:","category":"page"},{"location":"forecasting/","page":"Fisher forecasting","title":"Fisher forecasting","text":"using ForwardDiff, FiniteDiff\ndCl_dθ_ad = ForwardDiff.jacobian(Cl, θ0)\ndCl_dθ_fd = FiniteDiff.finite_difference_jacobian(Cl, θ0, Val{:central}; relstep = 5e-3) # TODO: 4e-2 is good for m_eV\n\nθnames = replace.(string.(pars_varying), \"₊\" => \".\")\ncolor = permutedims(eachindex(θnames))\nhline([NaN NaN], color = :black, linestyle = [:solid :dash], xlabel = \"l\", label = [\"AD\" \"FD\"])\nplot!(ls, dCl_dθ_ad ./ Cls; color, linestyle = :solid, label = \"∂(Cₗ)/∂(\" .* permutedims(θnames) .* \")\")\nplot!(ls, dCl_dθ_fd ./ Cls; color, linestyle = :dash, label = nothing)","category":"page"},{"location":"forecasting/","page":"Fisher forecasting","title":"Fisher forecasting","text":"We can now compute F and the parameter covariance matrix","category":"page"},{"location":"forecasting/","page":"Fisher forecasting","title":"Fisher forecasting","text":"C = F¹","category":"page"},{"location":"forecasting/","page":"Fisher forecasting","title":"Fisher forecasting","text":"which is simply the inverse of F:","category":"page"},{"location":"forecasting/","page":"Fisher forecasting","title":"Fisher forecasting","text":"fisher_matrix(dCl_dθ) = [sum(dCl_dθ[il,i]*dCl_dθ[il,j]/σs[il]^2 for il in eachindex(ls)) for i in eachindex(θ0), j in eachindex(θ0)]\nF_fd = fisher_matrix(dCl_dθ_fd)\nF_ad = fisher_matrix(dCl_dθ_ad)\nC_fd = inv(F_fd)\nC_ad = inv(F_ad)","category":"page"},{"location":"forecasting/","page":"Fisher forecasting","title":"Fisher forecasting","text":"Finally, we can plot ellipses for the forecasted parameter constraints in the multi-dimensional parameter space:","category":"page"},{"location":"forecasting/","page":"Fisher forecasting","title":"Fisher forecasting","text":"using Plots\n\nfunction ellipse(C::Matrix, i, j, c = (0.0, 0.0); nstd = 1, N = 33)\n    σᵢ², σⱼ², σᵢⱼ = C[i,i], C[j,j], C[i,j]\n    θ = (atan(2σᵢⱼ, σᵢ²-σⱼ²)) / 2\n    a = √((σᵢ²+σⱼ²)/2 + √((σᵢ²-σⱼ²)^2/4+σᵢⱼ^2))\n    b = √(max(0.0, (σᵢ²+σⱼ²)/2 - √((σᵢ²-σⱼ²)^2/4+σᵢⱼ^2)))\n\n    a *= nstd # TODO: correct?\n    b *= nstd # TODO: correct?\n\n    cx, cy = c\n    ts = range(0, 2π, length=N)\n    xs = cx .+ a*cos(θ)*cos.(ts) - b*sin(θ)*sin.(ts)\n    ys = cy .+ a*sin(θ)*cos.(ts) + b*cos(θ)*sin.(ts)\n    return xs, ys\nend\n\nfunction plot_ellipses!(p, C; label = nothing, kwargs...)\n    for i in eachindex(IndexCartesian(), C)\n        ix, iy = i[1], i[2]\n        if iy == 1 || iy > size(p)[1] + 1 || ix > size(p)[2]\n            continue # out of bounds; skip\n        end\n        subplot = p[iy-1, ix]\n        if ix >= iy\n            # upper triangular part\n            _label = (iy-1, ix) == (1, size(p)[2]) ? label : nothing\n            hline!(subplot, [NaN]; framestyle = :none, label = _label, legendfontsize = 10, kwargs...)\n        else\n            # lower triangular part\n            μx = θ0[ix]\n            μy = θ0[iy]\n            xlabel = iy == length(θ0) ? θnames[ix] : \"\"\n            ylabel = ix == 1 ? θnames[iy] : \"\"\n            for nstd in 1:2\n                xs, ys = ellipse(C, ix, iy, (μx, μy); nstd)\n                plot!(subplot, xs, ys; xlabel, ylabel, label = nothing, kwargs...)\n            end\n        end\n    end\n    return p\nend\n\np = plot(layout = (length(θ0)-1, length(θ0)-1), size = (1000, 1000), aspect = 1)\nplot_ellipses!(p, C_ad; color = :blue, linestyle = :solid, linewidth = 2, label = \"automatic differentiation\")\nplot_ellipses!(p, C_fd; color = :red, linestyle = :dash, linewidth = 2, label = \"finite differences\")","category":"page"},{"location":"getting_started/#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Install SymBoltz.jl and load it with","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"using SymBoltz","category":"page"},{"location":"getting_started/#1.-Create-the-model","page":"Getting started","title":"1. Create the model","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"The first step is to define our cosmological model. This is a symbolic representation of the variables and equations that describe the various components in the universe, such as the theory of gravity (like general relativity) and particle species (like the cosmological constant, cold dark matter, photons and baryons).","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"To get started, we will simply load the standard ΛCDM model:","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"M = ΛCDM()\nhierarchy(M; describe = true)","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"As shown, the model is structured as a hierarchy of the physical components. Each of these components contains a block of self-contained variables and equations that are independent from the other components, making up interchangeable modules of the entire Einstein-Boltzmann system. A full model joins several such incomplete blocks into a complete set of equations for the entire Einstein-Boltzmann system.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"The hierarchical structure can be inspected interactively (with TAB-completion) in the Julia REPL by evaluating M, M.G, M.G.ρ and so on. For example, to see all equations for the theory of gravity:","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"equations(M.G)","category":"page"},{"location":"getting_started/#2.-Solve-the-problem","page":"Getting started","title":"2. Solve the problem","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Next, we create a numerical representation of the cosmological problem we want to solve. This splits the full symbolic model into computational stages (like the background, thermodynamics and perturbations), assigns input values to parameters and defines any parameters that are solved for with the shooting method by matching conditions at the final time.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"using Unitful, UnitfulAstro # for interfacing without internal code units\npars = Dict(\n    M.γ.T₀ => 2.7,\n    M.c.Ω₀ => 0.27,\n    M.b.Ω₀ => 0.05,\n    M.ν.Neff => 3.0,\n    M.g.h => 0.7,\n    M.b.rec.Yp => 0.25,\n    M.h.m_eV => 0.06,\n    M.I.ln_As1e10 => 3.0,\n    M.I.ns => 0.95\n)\nks = 10 .^ range(-5, 1, length=500) / u\"Mpc\"\nprob = CosmologyProblem(M, pars)","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Finally, we can simply solve the problem:","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"sol = solve(prob, ks) # or just solve(prob) to solve only the background","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"warning: Warning\nConstructing the CosmologyProblem is an expensive operation! It compiles symbolics to numerics, and should not be used to update parameter values. To just update parameter values, use the parameter updater function.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"tip: Tip\nFor maximum performance, use the optimal BLAS backend for your platform, such as MKL for Intel processors. See the performance page for more information. For example:using MKL","category":"page"},{"location":"getting_started/#3.-Use-the-solution","page":"Getting started","title":"3. Use the solution","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"You are now free to do whatever you want with the solution object. For example, to get the time points used by the solver and corresponding values of the scale factor a(τ):","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"τs = sol[M.τ]\nas = sol(M.g.a, τs)","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Similarly, to get Phi(kτ) for the 500 wavenumbers we solved for at the same times:","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Φs = sol(M.g.Φ, τs, ks)","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"You could plot this with using Plots; plot(log10.(as), transpose(Φs)), but this is more convenient with the included plot recipe:","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"using Plots\nks_plot = [1e-3, 1e-2, 1e-1, 1e-0] / u\"Mpc\"\nplot(sol, log10(M.g.a), M.g.Φ, ks_plot) # lg(a) vs. Φ for 4 wavenumbers","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"We can also calculate the matter power spectrum:","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Ps = spectrum_matter(sol, ks)\nplot(log10.(ks/u\"1/Mpc\"), log10.(Ps/u\"Mpc^3\"); xlabel = \"lg(k/Mpc⁻¹)\", ylabel = \"lg(P/Mpc³)\", label = nothing)","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Similarly, we can calculate the angular CMB (TT) power spectrum:","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"ls = 10:10:1000\nDls = spectrum_cmb(:TT, prob, ls; normalization = :Dl, unit = u\"μK\")\nplot(ls, Dls; xlabel = \"l\", ylabel = \"l (l+1) Cₗ / 2π\", label = nothing)","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"And here is a condensed plot with several quantities:","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"p = plot(layout=(3, 3), size=(900, 700), tickfontsize=6, labelfontsize=6, legendfontsize=5)\nplot!(p[1], sol, log10(M.g.a), [M.b.ρ, M.c.ρ, M.γ.ρ, M.ν.ρ, M.h.ρ, M.Λ.ρ] ./ M.G.ρ)\nplot!(p[2], sol, log10(M.g.a), [M.b.w, M.c.w, M.γ.w, M.ν.w, M.h.w, M.Λ.w])\nplot!(p[3], sol, log10(M.g.a), log10(M.g.E))\nplot!(p[4], sol, log10(M.g.a), [M.b.rec.XHe⁺⁺, M.b.rec.XHe⁺, M.b.rec.XH⁺, M.b.rec.Xe])\nplot!(p[5], sol, log10(M.g.a), log10.([M.b.rec.Tγ, M.b.rec.Tb] ./ M.γ.T₀))\nplot!(p[6], sol, log10(M.g.a), log10(abs(M.b.rec.κ)))\nplot!(p[7], sol, log10(M.g.a), [M.g.Φ, M.g.Ψ], ks_plot)\nplot!(p[8], sol, log10(M.g.a), log10.(abs.([M.b.δ, M.c.δ, M.γ.δ, M.ν.δ, M.h.δ])), ks_plot; klabel = false)\nplot!(p[9], sol, log10(M.g.a), log10.(abs.([M.b.θ, M.c.θ, M.γ.θ, M.ν.θ, M.h.θ])), ks_plot; klabel = false)","category":"page"},{"location":"parameter_fitting/#Fitting-parameters","page":"Fitting parameters","title":"Fitting parameters","text":"","category":"section"},{"location":"parameter_fitting/","page":"Fitting parameters","title":"Fitting parameters","text":"This tutorial shows how to perform Bayesian parameter inference on a cosmological model by fitting it to data, and how to forecast parameter constraints from a covariance matrix that describes uncertainties and correlations of (unknown) observed data.","category":"page"},{"location":"parameter_fitting/#Pantheon-supernova-data","page":"Fitting parameters","title":"Pantheon supernova data","text":"","category":"section"},{"location":"parameter_fitting/","page":"Fitting parameters","title":"Fitting parameters","text":"We load the binned Pantheon dataset. This includes redshifts and apparent magnitudes of over 1000 Type Ia supernovae.","category":"page"},{"location":"parameter_fitting/","page":"Fitting parameters","title":"Fitting parameters","text":"using DataFrames, CSV, LinearAlgebra, PDMats, SymBoltz\n\nbinned = true # use compressed dataset in the documentation\ndocsdir = joinpath(pkgdir(SymBoltz), \"docs\")\nif binned # choose compressed dataset with 40 redshift bins\n    data = joinpath(docsdir, \"Pantheon/Binned_data/lcparam_DS17f.txt\")\n    Csyst = joinpath(docsdir, \"Pantheon/Binned_data/sys_DS17f.txt\")\nelse # choose full dataset with 1048 supernovae\n    data = joinpath(docsdir, \"Pantheon/lcparam_full_long.txt\")\n    Csyst = joinpath(docsdir, \"Pantheon/sys_full_long.txt\")\nend\n\n# Read data table\ndata = CSV.read(data, DataFrame, delim = \" \", silencewarnings = true)\n\n# Read covariance matrix of apparent magnitudes (mb)\nCsyst = CSV.read(Csyst, DataFrame, header = false) # long vector\nCsyst = collect(reshape(Csyst[2:end, 1], (Int(Csyst[1, 1]), Int(Csyst[1, 1])))) # to matrix\nCstat = Diagonal(data.dmb)^2 # TODO: should this be squared?\nC = Csyst + Cstat\n\n# Sort data and covariance matrix with decreasing redshift\nis = sortperm(data, :zcmb, rev = true)\nC = C[is, is]\nC = PDMat(Symmetric(C)) # efficient sym-pos-def matrix with Cholesky factorization\ndata = data[is, :]\nfirst(data, 10) # show 10 first rows","category":"page"},{"location":"parameter_fitting/","page":"Fitting parameters","title":"Fitting parameters","text":"Let us plot the apparent magnitude as a function of redshift, and the covariance matrix:","category":"page"},{"location":"parameter_fitting/","page":"Fitting parameters","title":"Fitting parameters","text":"using CairoMakie\nfig = Figure(size = (600, 800))\nax1 = Axis(fig[1, 1:2], xlabel = \"z\", ylabel = \"m\", title = \"Apparent brightness vs. redshift\")\nscatter!(ax1, data.zcmb, data.mb; markersize = 5, label = \"data (Pantheon)\")\nerrorbars!(ax1, data.zcmb, data.mb, data.dmb; linewidth = 1, whiskerwidth = 5)\nax2 = Axis(fig[2, 1]; xlabel = \"z\", ylabel = \"z\", title = \"Covariance matrix\", yreversed = true, aspect = 1)\nhm = heatmap!(ax2, extrema(data.zcmb), extrema(data.zcmb), C; colormap = :balance, colorrange = (-0.001, +0.001))\nColorbar(fig[2, 2], hm)\nfig","category":"page"},{"location":"parameter_fitting/#Predicting-distances","page":"Fitting parameters","title":"Predicting distances","text":"","category":"section"},{"location":"parameter_fitting/","page":"Fitting parameters","title":"Fitting parameters","text":"To predict luminosity distances theoretically, we solve the w0waCDM model:","category":"page"},{"location":"parameter_fitting/","page":"Fitting parameters","title":"Fitting parameters","text":"using SymBoltz\ng = SymBoltz.metric()\nK = SymBoltz.curvature(g)\nX = SymBoltz.w0wa(g; analytical = true)\nM = RMΛ(K = K, Λ = X)\nM = complete(SymBoltz.background(M); flatten = false)\nM = change_independent_variable(M, M.g.a; add_old_diff = true)\n# TODO: avoid complete and fix change_independent_variable to handle multivariate variables # hide\npars_fixed = Dict(M.τ => 0.0, M.r.T₀ => NaN, M.X.cₛ² => NaN)\npars_varying = [M.r.Ω₀, M.m.Ω₀, M.K.Ω₀, M.g.h, M.X.w0, M.X.wa]\n\ndL = SymBoltz.distance_luminosity_function(M, pars_fixed, pars_varying, data.zcmb)\nμ(p) = 5 * log10.(dL(p)[begin:end-1] / (10*SymBoltz.pc)) # distance modulus\n\n# Show example predictions\nMb = -19.3 # absolute supernova brightness (constant since SN-Ia are standard candles)\nbgopts = (alg = SymBoltz.Tsit5(), reltol = 1e-5, maxiters = 1e3)\np0 = [9.3e-5, 0.3, 0.0, 0.7, -1.0, 0.0] # fiducial parameters\nμs = μ(p0)\nmbs = μs .+ Mb\nlines!(ax1, data.zcmb, mbs; color = :black, label = \"theory (ΛCDM)\")\naxislegend(ax1, position = :rb)\nfig","category":"page"},{"location":"parameter_fitting/#Bayesian-inference","page":"Fitting parameters","title":"Bayesian inference","text":"","category":"section"},{"location":"parameter_fitting/","page":"Fitting parameters","title":"Fitting parameters","text":"To perform bayesian inference, we define a probabilistic model in Turing.jl:","category":"page"},{"location":"parameter_fitting/","page":"Fitting parameters","title":"Fitting parameters","text":"using Turing\n\n@model function supernova(μ_pred, mbs, C; Mb = Mb, Ωr0 = 9.3e-5)\n    # Parameter priors\n    h ~ Uniform(0.1, 1.0)\n    Ωm0 ~ Uniform(0.0, 1.0)\n    Ωk0 ~ Uniform(-1.0, +1.0)\n    w0 ~ Uniform(-2.0, 0.0)\n    wa ~ Uniform(-1.0, +1.0)\n\n    p = [Ωr0, Ωm0, Ωk0, h, w0, wa]\n    μs_pred = μ_pred(p)\n    if isempty(μs_pred)\n        Turing.@addlogprob! -Inf\n        return nothing\n    end\n    mbs_pred = μs_pred .+ Mb\n    return mbs ~ MvNormal(mbs_pred, C) # read \"measurements sampled from multivariate normal with predictions and covariance matrix\"\n\n    # equivalently:\n    #Δmb = mbs .- mbs_pred\n    #χ² = transpose(Δmb) * invC * Δmb\n    #Turing.@addlogprob! -1/2 * χ²\n    #return nothing\nend\n\n# https://github.com/JuliaStats/Distributions.jl/issues/1964 # TODO: get rid of? PR?\nfunction MvNormal(μ::AbstractVector{<:Real}, Σ::AbstractPDMat{<:Real})\n    R = Base.promote_eltype(μ, Σ)\n    Distributions.MvNormal{R, typeof(Σ), typeof(μ)}(μ, Σ)\nend\nfunction MvNormal(μ, Σ)\n    return Distributions.MvNormal(μ, Σ)\nend\n\nsn_w0waCDM = supernova(μ, data.mb, C);\nsn_ΛCDM = fix(sn_w0waCDM, w0 = -1.0, wa = 0.0);\nnothing # hide","category":"page"},{"location":"parameter_fitting/","page":"Fitting parameters","title":"Fitting parameters","text":"We can now sample from the model to obtain a MCMC chain for the ΛCDM model:","category":"page"},{"location":"parameter_fitting/","page":"Fitting parameters","title":"Fitting parameters","text":"chain = sample(sn_ΛCDM, NUTS(), 1000; initial_params = (h = 0.5, Ωm0 = 0.5, Ωk0 = 0.0))\nimport Plots, StatsPlots # don't collide with Makie\nPlots.plot(chain)","category":"page"},{"location":"parameter_fitting/","page":"Fitting parameters","title":"Fitting parameters","text":"Finally, we can visualize the high-dimensional chain with a corner plot using PairPlots.jl:","category":"page"},{"location":"parameter_fitting/","page":"Fitting parameters","title":"Fitting parameters","text":"using PairPlots\nlayout = (\n    PairPlots.Scatter(),\n    PairPlots.Contourf(sigmas = 1:2),\n    PairPlots.MarginHist(),\n    PairPlots.MarginDensity(color = :black),\n    PairPlots.MarginQuantileText(color = :black, font = :regular),\n    PairPlots.MarginQuantileLines(),\n)\npp = pairplot(chain => layout)","category":"page"},{"location":"parameter_fitting/","page":"Fitting parameters","title":"Fitting parameters","text":"We can easily repeat this for another model:","category":"page"},{"location":"parameter_fitting/","page":"Fitting parameters","title":"Fitting parameters","text":"sn_w0CDM_flat = fix(sn_w0waCDM, Ωk0 = 0.0, wa = 0.0);\n# TODO: describe Turing model more, e.g. loglikelihood(sn_fc, (h = 0.70, Ωm0 = 0.26, Ωk0 = 0.10, w0 = -1.01, wa = -0.07)) # hide\nchain = sample(sn_w0CDM_flat, NUTS(), 1000; initial_params = (h = 0.5, Ωm0 = 0.5, w0 = -1.0))\npp = pairplot(chain => layout)","category":"page"},{"location":"parameter_fitting/#Forecasting","page":"Fitting parameters","title":"Forecasting","text":"","category":"section"},{"location":"parameter_fitting/","page":"Fitting parameters","title":"Fitting parameters","text":"Planning future cosmological surveys involves forecasting the precision of the constraints they are believed to place on parameters. Here we show how one can perform forecasting by combining SymBoltz.jl with Turing.jl.","category":"page"},{"location":"parameter_fitting/","page":"Fitting parameters","title":"Fitting parameters","text":"To start, create another probabilistic supernova model, but instead of observed luminosity distances, we now use simulated luminosity distances in a fiducial cosmology:","category":"page"},{"location":"parameter_fitting/","page":"Fitting parameters","title":"Fitting parameters","text":"sn_fc_w0waCDM = supernova(μ, mbs, Diagonal(C));\nsn_fc_w0CDM_flat = fix(sn_fc_w0waCDM, Ωk0 = 0.0, wa = 0.0);\nnothing # hide","category":"page"},{"location":"parameter_fitting/#MCMC-driven-forecasting","page":"Fitting parameters","title":"MCMC-driven forecasting","text":"","category":"section"},{"location":"parameter_fitting/","page":"Fitting parameters","title":"Fitting parameters","text":"A general assumption-free, but expensive method to perform forecasting is to explore the likelihood using MCMC (as before, only against simulated data):","category":"page"},{"location":"parameter_fitting/","page":"Fitting parameters","title":"Fitting parameters","text":"chain_fc = sample(sn_fc_w0CDM_flat, NUTS(), 1000)\nPlots.plot(chain_fc)","category":"page"},{"location":"parameter_fitting/","page":"Fitting parameters","title":"Fitting parameters","text":"pars0 = Dict(pars_varying .=> p0)\ntruth = PairPlots.Truth((h = pars0[M.g.h], Ωm0 = pars0[M.m.Ω₀], w0 = pars0[M.X.w0]))\npp_fc = pairplot(chain_fc => layout, truth)","category":"page"},{"location":"parameter_fitting/#Fisher-forecasting","page":"Fitting parameters","title":"Fisher forecasting","text":"","category":"section"},{"location":"parameter_fitting/","page":"Fitting parameters","title":"Fitting parameters","text":"A less general, but cheaper method to perform forecasting is use a second-order approximation of the likelihood around the mean of the probability distribution (i.e. maximum of the likelihood). This technique is called Fisher forecasting, and requires calculation of the Fisher (information) matrix","category":"page"},{"location":"parameter_fitting/","page":"Fitting parameters","title":"Fitting parameters","text":"Fᵢⱼ = -leftfrac^2 log P(θ)θᵢ  θⱼright","category":"page"},{"location":"parameter_fitting/","page":"Fitting parameters","title":"Fitting parameters","text":"This effectively measures how quickly the likelihood falls from the maximum in different directions in parameter space. Under certain assumptions, the Fisher matrix is the inverse of the covariance matrix C = F¹.","category":"page"},{"location":"parameter_fitting/","page":"Fitting parameters","title":"Fitting parameters","text":"First, we ask Turing to estimate the maximum likelihood mode of the probabilistic model:","category":"page"},{"location":"parameter_fitting/","page":"Fitting parameters","title":"Fitting parameters","text":"maxl_fc = maximum_likelihood(sn_fc_w0CDM_flat; initial_params = [0.5, 0.5, -1.0]) # TODO: or MAP?\n@assert all(isapprox.(maxl_fc.values.array, [pars0[M.g.h], pars0[M.m.Ω₀], pars0[M.X.w0]]; atol = 1e-4)) # hide\nmaxl_fc # hide","category":"page"},{"location":"parameter_fitting/","page":"Fitting parameters","title":"Fitting parameters","text":"As expected, the maximum likelihood corresponds to our chosen fiducial parameters. Nevertheless, the returned mode estimate object offers convenience methods that greatly simplifies our following calculations. Next, we calculate the Fisher matrix from the maximum likelihood, and invert it to get the covariance matrix:","category":"page"},{"location":"parameter_fitting/","page":"Fitting parameters","title":"Fitting parameters","text":"using StatsBase\nF_fc = informationmatrix(maxl_fc)\nC_fc = inv(F_fc)","category":"page"},{"location":"parameter_fitting/","page":"Fitting parameters","title":"Fitting parameters","text":"Finally, we derive 68% (1σ) and 95% (2σ) confidence ellipses from the covariance matrix and draw them onto our corner plot:","category":"page"},{"location":"parameter_fitting/","page":"Fitting parameters","title":"Fitting parameters","text":"# https://www.astronomy.ohio-state.edu/weinberg.21/A8824/stats4.pdf # hide\n# TODO: \"you can use MCMC instead, with your anticipated measurement errors and setting the data equal to the values expected for your fiducial model\" # hide\n# https://arxiv.org/pdf/1205.3984 # hide\n# https://discourse.julialang.org/t/plot-ellipse-in-makie/82814/4 # hide\n# https://docs.juliaplots.org/latest/generated/statsplots/#Covariance-ellipses # hide\n# https://github.com/marcobonici/FisherPlot.jl/blob/main/src/FisherPlot.jl#L19 # hide\nfunction ellipse(C::Matrix, i, j, c = (0.0, 0.0); nstd = 1, N = 33)\n    σᵢ², σⱼ², σᵢⱼ = C[i,i], C[j,j], C[i,j]\n    θ = (atan(2σᵢⱼ, σᵢ²-σⱼ²)) / 2\n    a = √((σᵢ²+σⱼ²)/2 + √((σᵢ²-σⱼ²)^2/4+σᵢⱼ^2))\n    b = √(max(0.0, (σᵢ²+σⱼ²)/2 - √((σᵢ²-σⱼ²)^2/4+σᵢⱼ^2)))\n\n    a *= nstd # TODO: correct?\n    b *= nstd # TODO: correct?\n\n    cx, cy = c\n    ts = range(0, 2π, length=N)\n    xs = cx .+ a*cos(θ)*cos.(ts) - b*sin(θ)*sin.(ts)\n    ys = cy .+ a*sin(θ)*cos.(ts) + b*cos(θ)*sin.(ts)\n    return xs, ys\nend\n\nfor i in eachindex(IndexCartesian(), C_fc)\n    ix, iy = i[1], i[2]\n    ix >= iy && continue\n    μx = maxl_fc.values[ix]\n    μy = maxl_fc.values[iy]\n    for nstd in 1:2\n        xs, ys = ellipse(C_fc.array, ix, iy, (μx, μy); nstd)\n        lines!(pp_fc[iy,ix], xs, ys; color = :red)\n    end\nend\n\npp_fc","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"SymBoltz.jl is a package for solving the linearized Einstein-Boltzmann system of equations. It is designed to be simple to use, extend and integrate with the wider Julia and SciML ecosystems for scientific analysis.","category":"page"},{"location":"#Features","page":"Introduction","title":"Features","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Symbolic-numeric: Represents the Einstein-Boltzmann system symbolically and solves it numerically.\nExtendable: Facilitates development of extended models by representing each component (e.g. gravitational theory and every particle species) as modular blocks that are compiled into a full model.\nApproximation-free:  Does not rely on tight coupling, ultra-relativistic fluid and radiation streaming approximations, but implicitly integrates the full stiff equations with automatically generated Jacobians.\nDifferentiable: Enables sensitivity analysis with automatic differentiation of any output quantity.\nConvenient post-processing: Compute and plot any derived quantity by its expression with no extra code.\nSpectra: Compute linear and non-linear matter and CMB power spectra.\nGPU-accelerated: Optionally accelerates the solution over GPUs (TODO).","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"This is made possible by the packages ModelingToolkit.jl, DifferentialEquations.jl, ForwardDiff.jl, MatterPower.jl, DiffEqGPU.jl and more.","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Install and launch julia and install SymBoltz.jl in one of these two ways:","category":"page"},{"location":"#For-usage","page":"Introduction","title":"For usage","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"using Pkg; Pkg.add(\"SymBoltz\")","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"This installs the latest release of SymBoltz for use without permission to modify internals. You can still build and modify cosmological models as intended from the symbolic interface. The installation is tracked by Julia's package manager, and you can easily ] update to new releases. This is the recommended method for most users.","category":"page"},{"location":"#For-usage-and-development","page":"Introduction","title":"For usage and development","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"using Pkg; Pkg.develop(\"SymBoltz\")","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"This clones the development repository of SymBoltz for use with permission to modify any parts of the code. The installation is not tracked by Julia's package manager, and you are responsible for managing the local repository and pulling remote updates. See the package manager documentation to learn more. This is the recommended method for contributing users.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"tip: Tip\nFor a smooth development workflow, it is strongly recommended to install Revise.jl and load it before Symboltz.jl:using Pkg; Pkg.add(\"Revise\"); Pkg.dev(\"SymBoltz\")\nusing Revise, SymBoltz # Revise first!\n# 1) Modify SymBoltz.jl code\n# 2) Interactively try out new changes\n# 3) Rinse and repeatRevise automatically tracks changes made to the source files and reloads them in the active Julia session, so Julia does not have to be restarted after every change.","category":"page"},{"location":"#Usage-workflow","page":"Introduction","title":"Usage workflow","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Like most Julia packages, SymBoltz is intended for interactive use within a running julia REPL session, not by repeatedly executing scripts like julia script.jl from the shell. See Julia workflow tips to learn more.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Make sure to run julia --threads=auto with multi-threading to take advantage of internal parallellizations.","category":"page"}]
}
